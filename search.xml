<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[__has_include 对头文件是否存在进行判断]]></title>
    <url>%2F2019%2F07%2F22%2Fhas-include%2F</url>
    <content type="text"><![CDATA[我们在实际编写代码的时候，经常需要判断当前编译环境是否存在我们需要的头文件，根据存在情况做不同的操作 GCC 5开始支持的，Mac系统下 XCode自带的Clang编译器也是支持的。 可以这样使用，判断是否有这些文件，并且定义相应的宏，下面做不同的处理： 123456789101112#ifdef __has_include# if __has_include(&lt;optional&gt;)# include &lt;optional&gt;# define have_optional 1# elif __has_include(&lt;experimental/optional&gt;)# include &lt;experimental/optional&gt;# define have_optional 1# define experimental_optional# else# define have_optional 0# endif#endif 也可以这样使用来判断，导入不同的头文件： 12345# if __has_include(&lt;AFNetworking/AFNetworking.h&gt;)#import &lt;AFNetworking/AFNetworking.h&gt;#else#import &quot;AFNetworking.h&quot;#endif]]></content>
  </entry>
  <entry>
    <title><![CDATA[ubuntu上git搭建]]></title>
    <url>%2F2019%2F07%2F13%2Flinux-git%2F</url>
    <content type="text"><![CDATA[1、系统软件库的索引文件太旧了，先更新一下sudo apt-get update 2、安装git所需要的软件sudo apt-get install git-core openssh-server openssh-client 3、安装Python的setuptools和gitosis3.1 安装setuptoolssudo apt-get install python-setuptools 3.2 安装gitosis前 先配置git用户信息12git config --global user.name &quot;yourusername&quot;git config --global user.email &quot;youremail&quot; 3.3 获取gitosis文件git clone https://github.com/res0nat0r/gitosis.git 【中间有两个是数字零】 3.4 获取gitosis文件后，进入到文件目录下面12cd gitosis/ sudo python setup.py install 以上就安装完成了 4、创建git管理员账户、配置git4.1 创建git服务器管理员12sudo useradd -m git sudo passwd git 然后再/home目录下创建一个项目仓库存储点，并设置只有git用户拥有所有权限，其他用户没有任何权限。 123sudo mkdir /home/gitrepository sudo chown git:git /home/gitrepository/ sudo chmod 700 /home/gitrepository/ 由于gitosis默认状态下会将仓库放在用户的repositories目录下，例如git用户的仓库地址默认在/home/git/repositories/目录下，这里我们需要创建一个链接映射。让他指向我们前面创建的专门用于存放项目的仓库目录/home/gitrepository。 1sudo ln -s /home/gitrepository /home/git/repositories 这里我将在服务器端生成ssh公钥，如果想在其他机器上管理也可以在其他机器上生成一个ssh的公钥。ssh-keygen -t rsa 这里会提示输入密码，我们不输入直接回车即可。然后用刚生成公钥id_rsa.pub来对gitosis进行初始化。执行 sudo -H -u git gitosis-init &lt; /home/jackdeng/.ssh/id_rsa.pub出现如上信息说明gitosis已经初始化成功。 gitosis主要是通过gitosis-admin.git仓库来管理一些配置文件的，如用户权限的管理。这里我们需要对其中的一个post-update文件添加可执行的权限。1sudo chmod 755 /home/gitrepository/gitosis-admin.git/hooks/post-update 首先需要在前面生成ssh公钥（用来初始化gitosis）的机器上将gitosis-admin.git的仓库clone下来。在客户端机器上新建一个目录用于存放gitosis-admin.git仓库 git clone git@123.45.44.123:gitosis-admin.git clone下来会有一个gitosis.conf的配置文件和一个keydir的目录。gitosis.conf用于配置用户的权限信息，keydir主要用户存放ssh公钥文件（一般以“用户名.pub”命名，gitosis.conf配置文件中需使用相同用户名），用于认证请求的客户端机器。 现在让需要授权的用户使用前面的方式各自在其自己的机器上生成相应的ssh公钥文件，管理员把他们分别按用户名命名好，复制到keydir目录下。 1cp /home/aaaaa/Desktop/zhangsan.pub /home/aaaaa/gitadmin/gitosis-admin/keydir/ 继续编辑gitosis.conf文件 1234567891011121314[gitosis][group gitosis-admin] ####管理员组members = charn@ubuntu ####管理员用户名，需要在keydir目录下找到相应的.pub文件，多个可用空格隔开（下同）writable = gitosis-admin####可写的项目仓库名，多个可用空格隔开（下同）[group testwrite] ####可写权限组members = zhangsan####组用户writable = mytestproject####可写的项目仓库名[group testread]####只读权限组members =lisi####组用户readonly= mytestproject####只读项目仓库名]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL创建用户与授权]]></title>
    <url>%2F2019%2F07%2F13%2Fmysql-user%2F</url>
    <content type="text"><![CDATA[一. 创建用户1CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;; username：你将创建的用户名host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器 例子： 12345CREATE USER &apos;dog&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;;CREATE USER &apos;pig&apos;@&apos;192.168.1.101_&apos; IDENDIFIED BY &apos;123456&apos;;CREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;CREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;&apos;;CREATE USER &apos;pig&apos;@&apos;%&apos;; 二. 授权:1GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL databasename：数据库名tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用表示，如.* 例子: 12GRANT SELECT, INSERT ON test.user TO &apos;pig&apos;@&apos;%&apos;;GRANT ALL ON *.* TO &apos;pig&apos;@&apos;%&apos;; 注意:用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令: GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39; WITH GRANT OPTION; 三.设置与更改用户密码1234SET PASSWORD FOR &apos;username&apos;@&apos;host&apos; = PASSWORD(&apos;newpassword&apos;);如果是当前登陆用户用:SET PASSWORD = PASSWORD(&quot;newpassword&quot;); 例子: 1SET PASSWORD FOR &apos;pig&apos;@&apos;%&apos; = PASSWORD(&quot;123456&quot;); 四. 撤销用户权限1REVOKE privilege ON databasename.tablename FROM &apos;username&apos;@&apos;host&apos;; privilege, databasename, tablename：同授权部分例子:REVOKE SELECT ON *.* FROM &#39;pig&#39;@&#39;%&#39;; 注意:假如你在给用户&#39;pig&#39;@&#39;%&#39;授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO &#39;pig&#39;@&#39;%&#39;，则在使用REVOKE SELECT ON *.* FROM &#39;pig&#39;@&#39;%&#39;;命令并不能撤销该用户对test数据库中user表的SELECT操作。相反，如果授权使用的是GRANT SELECT ON *.* TO &#39;pig&#39;@&#39;%&#39;;则REVOKE SELECT ON test.user FROM &#39;pig&#39;@&#39;%&#39;;命令也不能撤销该用户对test数据库中user表的Select权限。具体信息可以用命令SHOW GRANTS FOR &#39;pig&#39;@&#39;%&#39;; 查看。 五.删除用户1DROP USER &apos;username&apos;@&apos;host&apos;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django Tutorial]]></title>
    <url>%2F2019%2F07%2F13%2Fdjango-tutorial%2F</url>
    <content type="text"><![CDATA[（一）Django 环境搭建0、介绍Python3：Python开发环境，与Python2不兼容 pip3：Python3的包和模块管理工具，类似iOS的Cocoapods管理工具 Django：一个基于Python的Web框架，是Python3的一个开发包，我们目前使用1.8版本 1、Python2和python3在Mac上的共存Mac上自带的Python路径是：/System/Library/Framwork/Python.Framework/versions/自带的版本是2.7版本的，然后在/usr/bin里面创建了相应的快捷命令：pythonpythonwpython-configpydoc等,xcode的正常运行是需要这一套环境的，所以不要把这一套环境破坏，另外安装python3.4 2、python3的安装如果已经正确安装直接跳过这个步骤 ###方法一：使用brew安装： brew install python3 这种方式会直接安装好python3和pip3 方法二：Python3安装包安装： 下载python3.4的安装包dmg文件安装后，安装目录在/Library/Framework/Python.framework/versions下，只安装一个3.4环境，它会默认在~/.bash_profile中添加bin目录，并且将pip3.4命令拷贝到/usr/local/bin下面，所以3.4和上面系统用到的python2版本基本上是可以独立运行的 需要注意的是，在终端中运行python时候，如果要运行python3.4，那么就使用python3.4命令，为了避免混淆，最好将/usr/bin下面的python命令删除，保留python2.7命令。 3、检查python3和pip3是否正确安装检查python3环境： python3 --version 检查pip3环境： pip3 --version 如果都能正确提示版本号，则安装完成 4、虚拟环境如果我们要同时开发多个应用程序，那这些应用程序都会共用一个Python每个应用可能需要各自拥有一套“独立”的Python运行环境。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。安装 virtualenv :pip3 install virtualenv 创建工程目录：mkdir yourprojectdir 创建虚拟环境：virtualenv --no-site-packages venv参数 –no-site-packages，表示 系统Python环境中的所有第三方包都不会复制过来 进入虚拟环境：source venv/bin/activate 退出虚拟环境：deactivate ##5、安装Django: 这里Django选择2.2版本,直接执行命令： pip3 install Django==2.2 如果没有出错，依赖环境就安装完成了 6、参考资料：1、廖雪峰Python3教程2、Django官方文档（需要注意版本）3、venev （二）Django Hello World0、介绍：这部分我们主要是： 创建一个Django项目，并实现一个helloworld的简单接口 1、创建名字为demoProject的项目：在你想要保存项目代码的目录下执行下面的命令： django-admin.py startproject demoProject 2、创建名字为hello的应用：项目和应用的关系 类似 iOS中 workspace 和 project的关系一个Django项目中可以有多个应用 执行以下命令创建名字为hello的应用： python3 manage.py startapp hello 3、项目目录结构介绍：此时项目的目录如下： demoProject/ manage.py一种命令行工具，可让你以各种方式与该 Django 项目进行交互python manage.py help查看他的功能 demoProject/ __init__.py:一个空文件，该文件将当前目录变成一个python开发包(模块)，一般不需要改动 setting.py：项目的配置文件 urls.py：URL设置，可看作网站的目录结构 wsgi.py：http服务器配置，动态网关接口配置文件 hello/ __init__.py 同上 admin.py ：配置模型models在django原生后台的管理 migrations/ 用来做版本管理 __init__.py 同上 models.py：模型代码 tests.py：单元测试代码 views.py：逻辑处理代码 templates 存放html模版文件 4、运行项目：cd demoProject 进入项目目录，执行下面的命令运行程序： python3 manage.py runserver 命令行提示如下： 1234567891011Performing system checks...System check identified no issues (0 silenced).You have unapplied migrations; your app may not work properly until they are applied.Run &apos;python manage.py migrate&apos; to apply them.July 23, 2018 - 07:36:17Django version 1.8, using settings &apos;demoProject.settings&apos;Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C. 打开浏览器访问：http://127.0.0.1:8000 如果提示上面的内容，说明我们的项目已经搭建好了 按下 control+c 可以关掉程序 5、添加helloworld接口：5.1、配置app修改demoProject/demoProject/settings.py文件在里面添加hello app应用123456789INSTALLED_APPS = ( &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;hello’ #新增) 5.2、 编写返回hello的接口在 demoProject/hello/views.py 里新增如下代码： 1234from django.http import HttpResponsedef sayHello(request): return HttpResponse(u&quot;Hello world!&quot;) 这里实现了一个sayHello的函数函数依赖了HttpResponse方法，所以需要从django.http模块中引入该方法 5.3、 添加路由在 demoProject/demoProject/urls.py 里新增如下代码: 12345678from django.contrib import adminfrom django.urls import pathfrom hello import views as helloViews #newurlpatterns = [ path(&apos;admin/&apos;, admin.site.urls), path(&apos;hello&apos;, helloViews.sayHello), #new] 这里就是Django关键的路由模块配置了url函数前半部分是模式匹配url地址函数，后面是调用的实现方法这里的意思是当访问/hello时，调用hello模块的views里的sayHello方法来处理 6、测试hello world再次执行下面的命令启动服务，如果当前正在运行，可以按Control+C关掉： python3 manage.py runserver 在浏览器访问地址： http://127.0.0.1:8000/hello 可以看到返回如下： 至此一个简单的hello world接口就好了，可以自己试试写点其他接口 7、参考资料：（三）Django 简单小程序接口实现0 介绍：这部分我们在之前项目基础上实现两个简单的接口，具体如下：1、小程序用户上传分数到服务端接口2、小程序用户获取分数排行版接口 1、创建并配置小程序应用：1.1、 在helloworld项目中新建应用wechatGame：python3 manage.py startapp wechatGame 1.2、将应用添加到项目配置:修改项目配置文件 demoProject/demoProject/settings.py12345678910INSTALLED_APPS = ( &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;hello&apos;, &apos;wechatGame&apos; #new) 2、创建Player玩家模型再应用的模型文件 demoProject/wechatGame/models.py 加入以下代码 12345678class Player(models.Model): playerID = models.AutoField(primary_key=True) nickName = models.CharField(max_length=50, default=&apos;&apos;) score = models.IntegerField(default=0) updateTime = models.DateTimeField(auto_now=True) def __str__(self): return self.nickName 这里创建了一个玩家的模型，包含用户昵称、用户分数、和分数更新时间字段利用Django强大的ORM功能，后面可以直接在数据库中生成对应的数据表 3、实现两个接口逻辑打开demoProject/wechatGame/views.py文件进行修改： 导入玩家模型：from wechatGame.models import Player 实现上传分数addScore和获取分数rank的接口,最终代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from django.shortcuts import render# Create your views here.from django.http import HttpResponsefrom wechatGame.models import Playerimport jsondef addScore(request): #获取客户端参数 nickName = request.GET.get(&apos;nickName&apos;) score = request.GET.get(&apos;score&apos;) if not nickName or not score: return HttpResponse(json.dumps(&#123; &quot;status&quot;: 1, &quot;errorMsg&quot;: &quot;param error&quot; &#125;)) score = max(int(score),0) #查看玩家是不是已经在数据库，如果在更新，否则创建玩家 isHave = True try: tmpData = Player.objects.get(nickName=nickName) except Exception as err: isHave = False if isHave: player = Player.objects.get(nickName=nickName) player.score = max(score,int(player.score)) else: player = Player(nickName=nickName,score=score) player.save()#保存到数据库 return HttpResponse(json.dumps(&#123; &quot;status&quot;: 0, &quot;errorMsg&quot;: &quot;&quot; &#125;))def rank(request): status = 0 errorMsg = &apos;&apos; print(&quot;========= 开始从数据库获取数据 ===========&quot;) players = Player.objects.all().order_by(&quot;-score&quot;) playersDic = [] for player in players: playersDic.append(&#123;&quot;nickName&quot;:player.nickName,&quot;score&quot;:player.score&#125;) print(&quot;playersDic%s&quot;%(playersDic)) return HttpResponse(json.dumps(&#123; &quot;status&quot;: status, &quot;errorMsg&quot;: errorMsg, &quot;players&quot;: playersDic &#125;)) 4、 在 urls 里配置路由在 demoProject/demoProject/urls.py 里新增如下代码: 1234567891011from django.contrib import adminfrom django.urls import pathfrom hello import views as helloViews from wechatGame import views as wechatViews #newurlpatterns = [ path(&apos;admin/&apos;, admin.site.urls), path(&apos;hello&apos;, helloViews.sayHello), path(&apos;score&apos;, wechatViews.addScore),#new path(&apos;rank&apos;, wechatViews.rank),#new] 5、将model应用到数据库因为我们新增了玩家的模型，所以在运行程序之前需要将模型结构同步到数据库 根据对modes的改动，生成对应的数据库语句，但是这个改动还没有作用到数据库文件python3 manger.py makemigrations 将改动应用到数据库 python3 manager.py migrate 执行完这两个步骤会在sqlite数据库里生成一张和Player对应的数据表用来存储数据 执行完之后可以看到项目目录下多了一个sqlite文件： 打开sqlite可以看到具体表和表结构： 6、测试接口启动服务 python3 manage.py runserver 打开浏览器访问接口： http://127.0.0.1:8000/rank http://127.0.0.1:8000/score?nickName=hello&amp;score=120 上传分数接口成功效果： 排行榜接口返回效果： 数据库里存储的数据： 至此，我们的两个接口实现就完成了 7、参考资料：（四）Django 管理后台1、创建初始管理员密码:python3 manage.py createsuperuser 2、访问管理后台：http://localhost:8000/admin/ （五）Django 简单的前端界面##0、介绍这部分主要用Django实现一个前端界面1、让用户可以输入用户名和分数，上传到服务端2、可以拉取当前排行榜列表 1、新建模板页面Django的模板语法可以实现 将python代码中的逻辑填充到html页面中，然后返回给浏览器 在demoProject/wechatGame下新建templates目录并在目录下新建 game.html文件 我们先在html文件里写点简单代码测试一下： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; hello world, i&apos;m html! &lt;/body&gt;&lt;/html&gt; 2、增加访问游戏页面接口在 demoProject/wechatGame/views.py 里添加函数： 12def gamePage(request): return render(request, &apos;game.html&apos;) 在 demoProject/demoProject/urls.py 里添加路由： path(&#39;game&#39;, wechatViews.gamePage) 启动服务： python3 manage.py runserver 打开浏览器测试： http://127.0.0.1:8000/game 出现以上页面，说明我们的页面可以使用了 3、编写游戏前端页面主要是实现随机生成游戏结果和上传分数的逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;我是小程序的标题&lt;/title&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; value=&quot;&quot; placeholder=&quot;请输入你的大名&quot; id=&quot;name_input&quot;&gt; &lt;br/&gt; &lt;br/&gt; &lt;label id=&quot;score_tip_label&quot;&gt;你的分数：&lt;/label&gt; &lt;label id=&quot;score_label&quot;&gt;0&lt;/label&gt; &lt;br/&gt; &lt;br/&gt; &lt;button type=&quot;button&quot; id=&quot;game_btn&quot;&gt;玩游戏&lt;/button&gt; &lt;button type=&quot;button&quot; id=&quot;score_btn&quot;&gt;上传分数&lt;/button&gt; &lt;button type=&quot;button&quot; id=&quot;rank_btn&quot;&gt;查看排行榜&lt;/button&gt; &lt;!-- 前端逻辑处理脚本 --&gt; &lt;script&gt; //获取 名字和分数 两个值 var scoreLabel = document.getElementById(&apos;score_label&apos;); var nameInput = document.getElementById(&apos;name_input&apos;); // 玩游戏 document.getElementById(&apos;game_btn&apos;).onclick = function() &#123; var name = name_input.value; //校验参数 if (name.length == 0) &#123; alert(&quot;请先输入你的大名！！！&quot;); return; &#125; //生成随机参数 0-1000 var randScore = parseInt(1000 * Math.random()) // alert(randScore) scoreLabel.innerText = randScore &#125;; //上传分数 document.getElementById(&apos;score_btn&apos;).onclick = function() &#123; var name = name_input.value; var score = scoreLabel.innerText //校验参数 if (name.length == 0) &#123; alert(&quot;请先输入你的大名！！！&quot;); return; &#125; //上传分数到服务端 $.ajax(&#123; &#123;% url %&#125;: &quot;/score&quot;, type: &quot;GET&quot;, data: &#123; &quot;nickName&quot;: name, &quot;score&quot;: score &#125;, success: function(data) &#123; var dataTmp = JSON.parse(data); var status = dataTmp[&apos;status&apos;] var msg = dataTmp[&apos;errorMsg&apos;] if (status == 0) &#123; alert(&quot;上传成功&quot;) &#125; else &#123; alert(msg) &#125; &#125; &#125;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、测试游戏和分数上传启动游戏服务：python3 manage.py runserver 打开浏览器访问：http://127.0.0.1:8000/game 输入昵称即可游戏和上传分数 5、编写排行榜逻辑demoProject/wechatGame/templates下新建rank.html该文件主要是列出当前排行榜数据具体实现代码如下： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;我是小程序的标题啊&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table id=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;名次&lt;/th&gt; &lt;th&gt;昵称&lt;/th&gt; &lt;th&gt;分数&lt;/th&gt; &lt;th&gt;游戏时间&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for player in players %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; player.nickName &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; player.score &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; player.updateTime &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% empty %&#125; &lt;div&gt; &lt;h4&gt;暂无排行榜数据&lt;/h4&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 在 demoProject/wechatGame/views.py 里添加函数： 1234def rankPage(request): #取出数据库中的排名数据 players = Player.objects.all().order_by(&quot;-score&quot;) return render(request, &apos;rank.html&apos;,&#123;&quot;players&quot;:players&#125;) 在 demoProject/demoProject/urls.py 里添加路由： path(&#39;getrank&#39;, wechatViews.rankPage) 启动服务： python3 manage.py runserver 打开浏览器测试： http://127.0.0.1:8000/getrank 可以配置游戏页面的查看排行榜按你链接跳转到排行榜： &lt;button type=&quot;button&quot; id=&quot;rank_btn&quot; onclick=&quot;javascript:window.location.href=&#39;http://127.0.0.1:8000/getrank&#39;&quot;&gt;查看排行榜&lt;/button&gt; 这样我们就完成了我们所有的逻辑。 6、参考资料：1、html教程]]></content>
  </entry>
  <entry>
    <title><![CDATA[memery manager]]></title>
    <url>%2F2019%2F07%2F13%2Fios-memery%2F</url>
    <content type="text"><![CDATA[1、什么是ARC 和 MRC？MRC（MannulReference Counting） ：手工内存管理，需要开发者自己在正确的位置写 retain 和 release ARC (Automatic Reference Counting)：自动内存管理，编译器通过静态分析，在编译时，帮助开发者在正确的位置插入内存管理代码 。 2、什么是引用计数？引用计数（Reference Count），通过计算引用数量来管理内存的方式。当我们创建一个对象的时候，他的引用计数是1，当有一个新的指针指向对象的时候，将引用计数+1，当指针不再指向对象的时候，将引用计数-1，当对象的引用计数为0的时候，说明这个对象不再被任何对象引用了，就会被销毁释放，回收内存。 为什么要用引用计数：一般内存管理原则是 “谁申请谁释放”，但是有个问题是，有时候 A 将对象 M 传给 B使用，这时候该由谁来释放呢？1、A释放，B拷贝一份 然后自己管理，这会导致内存分配释放等操作，浪费资源。2、B释放，A不释放，这就需要开发者自己去管理这些内存，A申请，B释放十分混乱，当多个地方都需要M的时候会有很多问题，过于复杂。 引用计数非常简单，B使用M就把计数+1，用完之后-1，内存管理完全交给引用计数即可。 3、弱引用的实现原理是什么？系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。这样，当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。 所以弱引用是有开销的。 4、Core Foundation 对象的内存怎么管理？Core Foundation对象大多以 XxxCreateWithXxx 来创建对于这些对象的引用计数的修改，要相应的使用 CFRetain 和 CFRelease 方法。 在 ARC 下，我们有时需要将一个 Core Foundation 对象转换成一个 Objective-C 对象，这个时候我们需要告诉编译器，转换过程中的引用计数需要做如何的调整。这就引入了bridge相关的关键字 __bridge: 只做类型转换，不修改相关对象的引用计数，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法。 __bridge_retained：类型转换后，将相关对象的引用计数加 1，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法。 __bridge_transfer：类型转换后，将该对象的引用计数交给 ARC 管理，Core Foundation 对象在不用时，不再需要调用 CFRelease 方法。 4、对象的 reatinCount 属性准确吗？并不准确，根据苹果官方文档介绍，是不准确的。 链接 There should be no reason to explicitly ask an object what its retain count is (see retainCount). The result is often misleading, as you may be unaware of what framework objects have retained an object in which you are interested. In debugging memory management issues, you should be concerned only with ensuring that your code adheres to the ownership rules. 5、autorelease 对象什么时候释放？autorelease 使得对象在超出生命周期后能正确的被释放(通过调用release方法)。在调用 release 后，对象会被立即释放，而调用 autorelease 后，对象不会被立即释放，而是注册到 autoreleasepool 中，经过一段时间后 pool结束，此时调用release方法，对象被释放。 当对一个对象调用 autorelease 时，不会立即发生release操作对引用计数-1，而是当这段语句所处的 autoreleasepool 进行 drain 操作时，所有标记了 autorelease 的对象的 retainCount 会被 -1。即 release 消息的发送被延迟到 pool 释放的时候了。 6、自动释放池怎么理解？当我们需要创建和销毁大量的对象时，使用手动创建的 autoreleasepool 可以有效的避免内存峰值的出现。因为如果不手动创建的话，外层系统创建的 pool 会在整个 runloop circle 结束之后才进行 drain，手动创建的话，会在 block 结束之后就进行 drain 操作。 系统在 runloop 中创建的 autoreleaspool 会在 runloop 一个 event 结束时进行释放操作。我们手动创建的 autoreleasepool 会在 block 执行完成之后进行 drain 操作。需要注意的是： 当 block 以异常（exception）结束时，pool 不会被 drain Pool 的 drain 操作会把所有标记为 autorelease 的对象的引用计数减一，但是并不意味着这个对象一定会被释放掉 7、main 函数里的那个 autorelase pool 什么时候释放？UIApplicationMain 函数是整个 app 的入口，用来创建 application 对象（单例）和 application delegate。尽管这个函数有返回值，但是实际上却永远不会返回，当按下 Home 键时，app 只是被切换到了后台状态。 main.m 中的 UIApplicationMain 永远不会返回，只有在系统 kill 掉整个 app 时，系统会把应用占用的内存全部释放出来。 UIApplicationMain 永远不会返回，这里的 autorelease pool 也就永远不会进入到释放那个阶段 假设有些变量真的进入了 main.m 里面这个 pool（没有被更内层的 pool 捕获），那么这些变量实际上就是被泄露的。这个 autorelease pool 等于是把这种泄露情况给隐藏起来了。 UIApplication 自己会创建 main run loop，在 Cocoa 的 runloop 中实际上也是自动包含 autorelease pool 的，因此 main.m 当中的 pool 可以认为是没有必要的。 8、函数返回值什么时候释放？如果一个函数的返回值是一个对象的指针，那这个对象肯定不能在返回之前直接释放掉对此，OC 对对象指针的返回值进行了区分，一种叫做 retained return value，另一种叫做 unretained return value。前者表示调用者拥有这个返回值，后者表示调用者不拥有这个返回值，按照“谁拥有谁释放”的原则，对于前者调用者是要负责释放的，对于后者就不需要了。 按照苹果的命名 convention，以 alloc, copy, init, mutableCopy 和 new 这些方法打头的方法，返回的都是 retained return value，例如 [[NSString alloc] initWithFormat:]，而其他的则是 unretained return value，例如 [NSString stringWithFormat:]。我们在编写代码时也应该遵守这个 convention。 MRC下 unretained return value 的对象，方法实现要做autorelease操作，因为外边调用者不reatain，他不拥有。所以不用释放。 ARC下 会自动帮我们加好这一切，所以可以直接使用。对于unretained return value ARC会把对象的生命周期延长，但是并不能保证都在自动释放池里，只是根据需要。 9、[NSObject new]与[[NSObject alloc] init] 有什么区别？[NSObject new]与[[NSObject alloc] init]是完全一致的。 10、autorelease是NSObject的实例方法，NSAutoreleasePool也是继承NSObject的类。那能不能调用autorelease呢？不能12NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];[pool release]; 运行结果发生崩溃。通常在使用Objective-C，也就是Foundation框架时，无论调用哪一个对象的autorelease实例方法，实现上是调用的都是NSObject类的autorelease实例方法。但是对于NSAutoreleasePool类，autorelease实例方法已被该类重载，因此运行时就会出错。 11、强制arc 和 mrc？在Project里面找到Build Phases-Compile Sources，这里是所有你的编译文件。指定编译器属性为-fobjc-arc即为该文件使用ARC，指定编译器属性为-fno-objc-arc即为该文件不使用ARC 12、所有权修饰符是啥？Objective-C编程中为了处理对象，可将变量类型定义为id类型或各种对象类型。 ARC中，id类型和对象类其类型必须附加所有权修饰符。 strong修饰符 weak修饰符unsafe_unretained修饰符 autoreleasing修饰符 strong修饰符是id类型和对象类型默认的所有权修饰符。也就是说，不写修饰符的话，默认对象前面被附加了strong所有权修饰符。123id obj = [[NSObject alloc] init];等同于id __strong obj = [[NSObject alloc] init]; unsafe_unretained修饰符是不安全的修饰符，尽管ARC式的内存管理是编译器的工作，但附有unsafe_unretained修饰符的变量不属于编译器的内存管理对象。 有时候autoreleasing修饰符要和weak修饰符配合使用。 123id __weak obj1 = obj0;id __autoreleasing tmp = obj1; 复制代码为什么访问附有weak修饰符的变量时必须访问注册到autoreleasepool的对象呢？这是因为weak修饰符只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。如果把访问的对象注册到autoreleasepool中，那么在@autoreleasepool块结束之前都能确保该对象存在。 13、在ARC下，C语言的结构体中可以有 OC对象吗？对象型变量不能作为C语言结构体（struct、union）的成员 1234//显示警告: ARC forbids Objective-C objects in structstruct Data &#123; NSMutableArray *array;&#125;; 在C语言的规约上没有方法来管理结构体成员的生命周期。因为ARC把内存管理的工作分配给编译器，所以编译器必须能够知道并管理对象的生命周期。例如C语言的局部变量可使用该变量的作用域管理对象。但是对于C语言的结构体成员来说，这在标准上就是不可实现的。 要把对象类型添加到结构体成员中，可以强制转换为void *或是附加__unsafe_unretained修饰符。 123struct Data &#123; NSMutableArray __unsafe_unretained *array;&#125;; __unsafe_unretained修饰符的变量不属于编译器的内存管理对象。 14、可以声明下面这个名字的属性吗？@property (nonatomic, copy) NSString *newString;编译器会报错 // 编译器不允许 编译器约定，对于alloc,init,copy,mutableCopy,new这几个家族的方法，后面默认加NS_RETURNS_RETAINED标识；而其他不指名标识的family的方法默认添加NS_RETURNS_NOT_RETAINED标识 参考资料理解 iOS 的内存管理Objective-c 内存管理iOS内存管理详解 Objective-C 中的内存分配]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[property]]></title>
    <url>%2F2019%2F07%2F13%2Fios-property%2F</url>
    <content type="text"><![CDATA[1、@property 后面可以有哪些修饰符？分为原子性、存取方法、内存管理、重写方法四组： 1、nonatomic / atomic(默认)2、readonly / readwrite(默认)3、retain / copy / strong /weak / assign / unsafe_unretained4、getter和setter对存取方法重命名5、nonull / nullable 详细解释：1、atomic/nonatomic指定合成存取方法是否为原子操作，可以理解为是否线程安全。可以发现几乎所有代码的属性设置都会使用nonatomic，这样能够提高访问性能，在iOS中使用锁机制的开销较大，会损耗性能。 2、readwrite/readonly readwrite是编译器的默认选项，表示自动生成getter和setter，如果需要getter和setter不写即可。readonly表示只合成getter而不合成setter。 3、assignassign表示对属性只进行简单的赋值操作，不更改所赋的新值的引用计数，也不改变旧值的引用计数，常用于标量类型，如NSInteger，NSUInteger，CGFloat，NSTimeInterval等。 assign也可以修饰对象如NSString等类型对象，上面说过使用assign修饰不会更改所赋的新值的引用计数，也不改变旧值的引用计数，如果当所赋的新值引用计数为0对象被销毁时属性并不知道，编译器不会将该属性置为nil，指针仍旧指向之前被销毁的内存，这时访问该属性会产生野指针错误并崩溃，因此使用assign修饰的类型一定要为标量类型。 非常危险。 4、weakweak表示对所赋的值对象持有弱引用表示一种“非拥有关系”(nonowning relationship)，weak修饰的时候同样不会增加所赋的新值的引用计数，也不减少旧值的引用计数，但当该值被销毁时，weak修饰的属性会被自动赋值为nil，这样就可以避免野指针错误。weak常用在修饰delegate等防止循环引用的场景。 5、unsafe_unretained使用unsafe_unretained修饰时效果与assign相同，不会增加引用计数，当所赋的值被销毁时不会被置为nil可能会发生野指针错误。unsafe_unretained与assign的区别在于，unsafe_unretained只能修饰对象，不能修饰标量类型，而assign两者均可修饰。 在使用中它的用处主要有下面几点： 兼容性考虑。iOS4 以及之前还没有引入 weak，这种情况想表达弱引用的语义只能使用 unsafe_unretained。这种情况现在已经很少见了。 性能考虑。使用 weak 对性能有一些影响，因此对性能要求高的地方可以考虑使用 unsafe_unretained 替换 weak。一个例子是 YYModel 的实现，为了追求更高的性能，其中大量使用 unsafe_unretained 作为变量标识符。 6、strongstrong表示属性对所赋的值持有强引用表示一种“拥有关系”(owning relationship)，会先保留新值即增加新值的引用计数，然后再释放旧值即减少旧值的引用计数。只能修饰对象。如果对一些对象需要保持强引用则使用strong。 7、copycopy修饰的属性会在内存里拷贝一份对象，两个指针指向不同的内存地址。一般用来修饰有对应可变类型子类的对象。如：NSString/NSMutableString,NSArray/NSMutableArray,NSDictionary/NSMutableDictionary等。为确保这些不可变对象因为可变子类对象影响，需要copy一份备份，如果不使用copy修饰，使用strong或assign等修饰则会因为多态导致属性值被修改。copy还被用来修饰block。 对于可变对象类型，如NSMutableString、NSMutableArray等则不可以使用copy修饰，因为Foundation框架提供的这些类都实现了NSCopying协议，使用copy方法返回的都是不可变对象，如果使用copy修饰符在对可变对象赋值时则会获取一个不可变对象，接下来如果对这个对象进行可变对象的操作则会产生异常，因为OC没有提供mutableCopy修饰符，对于可变对象使用strong修饰符即可 8、retain在ARC环境下使用较少，在MRC下使用效果与strong一致。 2、使用 property 相比 直接使用变量有什么好处？1、自动生成 getter 和 setter方法。当声明一个属性(property)的时候编译器默认情况下会自动生成相关的getter和setter方法2、这些方法的声明的更规范，更容易看出用处3、能够传递额外的行为信息 ，上面列出的各种修饰符，可以控制额外的行为 3、当给一个用copy修饰的NSString 赋值时，会在内存中拷贝一份吗？答案：不一定会，看赋值时否是可变类型原因：有时候我们需要copy一个对象，或是mutableCopy一个对象，这时需要遵守NSCopying和NSMutableCopying协议，来实现copyWithZone:和mutableCopyWithZone:两个方法，而不是重写copy和mutableCopy两个方法。Foundation框架中的很多数据类型已经帮我们实现了上述两个方法，因此我们可以使用copy方法和mutableCopy方法来复制一个对象，两者的区别在于copy的返回值仍未不可变对象，mutableCopy的返回值为可变对象。 type copy mutableCopy NS* 浅拷贝，只拷贝指针，地址相同 单层深拷贝，拷贝内容，地址不同 NSMutable* 单层深拷贝，拷贝内容，地址不同 单层深拷贝，拷贝内容，地址不同 由上述表格可以看出，对于不可变类型，使用copy方法时是浅拷贝，只拷贝指针，因为内容是不会变化的。使用mutableCopy时由于返回可变对象因此需要一份拷贝，供其他对象使用。对于可变类型，不管是copy还是mutableCopy均会进行深拷贝，所指向指针不同。 所以，在修饰NSString这样的不可变对象的时候使用copy修饰，但其实当给对象赋一个NSString时仍旧只复制了指针而不是拷贝内容。 #3、为什么block要用copy来修饰？ 在MRC内存管理时代，block内存默认是是分配在栈上的（不考虑全局block的情况），可能随时被回收掉。当方法执行完之后，就会被回收掉。指向他的指针也会变成野指针。如果想在超出block定义时的生命周期范围之外使用，那么需要执行block的copy方法将其复制到堆上。所以在对block变量赋值的时候，需要把block通过copy拷贝到堆上，然后一直强引用着。在MRC下对block类型的成员属性修饰最好用copy，而不要用retain，由于使用retain修饰只会改变引用计数而不会执行copy方法将block复制到堆上。此外block是一个对象就更不可能用assign修饰了。 在ARC环境下，只要将block赋值就会自动拷贝到堆上。那么ARC环境下什么情况block会被copy到堆上呢？1.执行copy方法。2.作为方法返回值。3.将Block赋值给非weak修饰的变量4.作为UsingBlock或者GCD的方法入参时。(暂无法验证)所以：一般来说我们使用block都是会有赋值操作的，由于有上述条件的存在，所以基本上不会遇到在栈上的block的情况。所以在ARC环境下，block类型的成员属性使用strong或copy修饰其实都可以，但是为了延续MRC的习惯，另外避免真的出现一些奇怪问题的情况，通常还是使用copy修饰。 3、常见使用场景1、懒加载的实现在很多情况下很常用，比如:创建一个比较大的而又不一定会使用的对象 ，可以再get方法中去创建。 4、@synthesize和@dynamic分别有什么作用？1、@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;2、@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。3、@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。 5、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？1、对应基本数据类型默认关键字是atomic,readwrite,assign 对于普通的 Objective-C 对象atomic,readwrite,strong 6、在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？ 1、同时重写了 setter 和 getter 时2、重写了只读属性的 getter 时3、使用了 @dynamic 时4、在 @protocol 中定义的所有属性5、在 category 中定义的所有属性6、重载的属性 当你在子类中重载了父类中的属性，你必须 使用 @synthesize 来手动合成ivar。 除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理 @property 的所有内容时，你就会尝试通过实现 @property 的所有“存取方法”（the accessor methods）或者使用 @dynamic 来达到这个目的，这时编译器就会认为你打算手动管理 @property，于是编译器就禁用了 autosynthesis（自动合成）。 因为有了 autosynthesis（自动合成），大部分开发者已经习惯不去手动定义ivar，而是依赖于 autosynthesis（自动合成），但是一旦你需要使用ivar，而 autosynthesis（自动合成）又失效了，如果不去手动定义ivar，那么你就得借助 @synthesize 来手动合成 ivar。 其实，@synthesize 语法还有一个应用场景，但是不太建议大家使用： 可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字:12345678@implementation CYLPerson @synthesize firstName = _myFirstName; @synthesize lastName = _myLastName; @end``` 上述语法会将生成的实例变量命名为 _myFirstName 与 _myLastName，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。举例说明：应用场景： //// .m文件// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)// https://github.com/ChenYilong// 打开第14行和第17行中任意一行，就可编译成功 @import Foundation; @interface CYLObject : NSObject@property (nonatomic, copy) NSString *title;@end @implementation CYLObject { // NSString *_title;} //@synthesize title = _title; (instancetype)init{ self = [super init]; if (self) { _title = @&quot;微博@iOS程序犭袁&quot;; } return self;} (NSString *)title { return _title;} (void)setTitle:(NSString *)title { _title = [title copy];} @end` 结果编译器报错： enter image description here 当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择： 要么如第14行：手动创建 ivar要么如第17行：使用@synthesize foo = _foo; ，关联 @property 与 ivar。 7、 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？不能向编译后得到的类中增加实例变量；能向运行时创建的类中添加实例变量；解释下： 因为编译后的类已经注册在 runtime 中，类结构体中的 objc_ivar_list 实例变量的链表 和 instance_size 实例变量的内存大小已经确定，同时runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量； 运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。 #参考资料iOS @property探究(一) 基础详解iOS @property探究(二) 深入理解block的理解与研究]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runtime]]></title>
    <url>%2F2019%2F07%2F13%2Fios-runtime%2F</url>
    <content type="text"><![CDATA[1、Runtime是什么？首先需要理解静态语言和动态语言，才能更好的理解Runtime 静态语言：比如C语言，编译阶段就需要决定好调用哪个函数，如果函数未实现就会编译报错。动态语言：比如OC，编译阶段不决定真正调用哪个函数，只要函数声明过，即使没有实现也不会报错。把决定调用的工作推迟到运行阶段。 所以就需要一个运行时系统来执行编译后的代码，正确的调用函数。Runtime就是OC的运行时系统。决定函数调用是Runtime最重要的工作。 2、[receiver message] 背后到底发生了什么？编译器会将 调用方法转成下面这个方法的调用： objc_msgSend(id _Nullable self, SEL _Nonnull op, ...) 第一个参数是id 类型，它是一个指向类实例的指针： 12/// A pointer to an instance of a class.typedef struct objc_object *id; 这里 objc_object 是一个结构体：1234/// Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;; isa 指针不总是指向实例对象所属的类，不能依靠它来确定类型。因为KVO的原理就是把对象的isa指针指向一个中间类。可以用 class 方法来确定实例对象的类。 Class 其实是一个指向 objc_class 的指针：12/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class; objc_class 的结构大概是这样的：123struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125; OBJC2_UNAVAILABLE; objc_class 里包含：123456789Class _Nullable super_class; //父类const char * _Nonnull name //类名;long version; //版本long info; //long instance_size; //struct objc_ivar_list * _Nullable ivars; //实例变量列表struct objc_method_list * _Nullable * _Nullable methodLists;//方法列表struct objc_cache * _Nonnull cache; //缓存struct objc_protocol_list * _Nullable protocols; //协议列表 第二个参数 SEL 本质是 objc_selector 结构体 12/// An opaque type that represents a method selector.typedef struct objc_selector *SEL; 可以用 Objc编译命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获得一个 SEL 类型的方法选择器。 不同类中相同名字的方法对应的 方法选择器 是相同的，即使参数类型不同。 上面的调用中[receiver message]，在编译阶段确定了向哪个接收者发送message消息，但是接受者具体如何响应决定于运行时的判断。 具体流程是：1、检测selector 是不是需要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会retain,release 这些函数了。 2、检测target 是不是nil 对象。ObjC 的特性是允许对一个 nil对象执行任何一个方法不会 Crash，因为会被忽略掉。 3、如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，若可以找得到就跳到对应的函数去执行。 4、如果在cache里找不到就找一下方法列表methodLists。 5、如果methodLists找不到，就到超类的方法列表里寻找，一直找，直到找到NSObject类为止。 6、如果还找不到，Runtime就提供了如下三种方法来处理：动态方法解析、消息接受者重定向、消息重定向，这三种方法的调用关系如下图： 其中：1.动态方法解析(Dynamic Method Resolution)所谓动态解析，我们可以理解为通过cache和方法列表没有找到方法时，Runtime为我们提供一次动态添加方法实现的机会，主要用到的方法如下： 12345678910111213141516171819//OC方法：//类方法未找到时调起，可于此添加类方法实现+ (BOOL)resolveClassMethod:(SEL)sel//实例方法未找到时调起，可于此添加实例方法实现+ (BOOL)resolveInstanceMethod:(SEL)sel//Runtime方法：/** 运行时方法：向指定类中添加特定方法实现的操作 @param cls 被添加方法的类 @param name selector方法名 @param imp 指向实现方法的函数指针 @param types imp函数实现的返回值与参数类型 @return 添加方法是否成功 */BOOL class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) 消息接收者重定向我们注意到动态方法解析过程中的两个resolve方法都返回了布尔值，当它们返回YES时方法即可正常执行，但是若它们返回NO，消息发送机制就进入了消息转发(Forwarding)的阶段了，我们可以使用Runtime通过下面的方法替换消息接收者的为其他对象，从而保证程序的继续执行。 12345//重定向类方法的消息接收者，返回一个类;+ (id)forwardingTargetForSelector:(SEL)aSelector//重定向实例方法的消息接受者，返回一个实例对象;如果这个方法返回了self会导致死循环- (id)forwardingTargetForSelector:(SEL)aSelector 消息重定向当以上两种方法无法生效，那么这个对象会因为找不到相应的方法实现而无法响应消息，此时Runtime系统会通过forwardInvocation：消息通知该对象，给予此次消息发送最后一次寻找IMP的机会： - (void)forwardInvocation:(NSInvocation *)anInvocation； 每个对象都从NSObject类中继承了forwardInvocation：方法，但是NSObject中的这个方法只是简单的调用了doesNotRecongnizeSelector:方法，提示我们错误。所以我们可以重写这个方法：对不能处理的消息做一些默认处理，也可以将消息转发给其他对象来处理，而不抛出错误。 anInvocation是forwardInvocation唯一参数，它封装了原始的消息和消息参数。正是因为它，我们还不得不重写另一个函数：methodSignatureForSelector。这是因为在forwardInvocation: 消息发送前，Runtime系统会向对象发送methodSignatureForSelector消息，并取到返回的方法签名用于生成NSInvocation对象。 注意：1、forwardingTargetForSelector仅支持一个对象的返回，也就是说消息只能被转发给一个对象，而forwardInvocation可以将消息同时转发给任意多个对象，这就是两者的最大区别。2、虽然理论上可以重载doesNotRecognizeSelector函数实现保证不抛出异常（不调用super实现），但是苹果文档着重提出“一定不能让这个函数就这么结束掉，必须抛出异常”3、forwardInvocation甚至能够修改消息的内容，用于实现更加强大的功能。 #3、isKindOfClass:、isSubclassOfClass:和isMemberOfClass: 分别是什么？有什么区别？原理是什么？ isKindOfClass:判断一个对象是否是 参数 的实例，或者参数父类的实例 isMemberOfClass: 判断一个对象是不是当前类的一个实例，是否跟父类有关系他不管，必须是当前类 isSubclassOfClass：+方法，表示调用该方法的类 是不是 参数类的一个子类 或者 是这个类的本身，和isKindOfClass类似 12345678910111213141516171819202122232425262728+ (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;- (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;+ (BOOL)isMemberOfClass:(Class)cls &#123; return object_getClass((id)self) == cls;&#125;- (BOOL)isMemberOfClass:(Class)cls &#123; return [self class] == cls;&#125;+ (BOOL)isSubclassOfClass:(Class)cls &#123; for (Class tcls = self; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125; #4、class 方法返回的是什么？原理是什么？- (Class)class; //返回一个对象的类对象+ (Class)class; //给类对象发送class消息，会返回类对象自身 内部实现大概是这样：123456+ (Class)class&#123; return self;&#125;- (Class)class&#123; return object_getClass(self);&#125; 而 object_getClass() 方法实际上是返回对象的isa 指针所指的对象：1234Class object_getClass(id obj)&#123; if (obj) return obj-&gt;getIsa(); else return Nil;&#125; 5、还有什么Runtime提供的方法？12345-respondsToSelector: //检查对象能否响应指定的消息；-conformsToProtocol: //检查对象是否实现了指定协议类的方法；-methodForSelector: //返回指定方法实现的地址。 6、在类方法中self是谁？在实例方法中self是 实例对象 [self class] 是类对象在类方法中self是 类对象 [self class] 也是类对象，其实就是他自己 7、 Runtime能用来干啥?一、动态方法交换：Method Swizzling 1、实现动态方法交换(Method Swizzling )是Runtime中最具盛名的应用场景，其原理是：通过Runtime获取到方法实现的地址，进而动态交换两个方法的功能。使用到关键方法如下：123456//获取类方法的MthodMethod _Nullable class_getClassMethod(Class _Nullable cls, SEL _Nonnull name)//获取实例对象方法的MthodMethod _Nullable class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)//交换两个方法的实现void method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2) 2.拦截并替换系统方法Runtime动态方法交换更多的是应用于系统类库和第三方框架的方法替换。在不可见源码的情况下，我们可以借助Rutime交换方法实现，为原有方法添加额外功能，这在实际开发中具有十分重要的意义。一般放到 +load 方法里：123456789//load方法不需要手动调用，iOS会在应用程序启动的时候自动调起load方法，而且执行时间较早，所以在此方法中执行交换操作比较合适。+ (void)load&#123; //获取系统方法地址 Method sytemMethod = class_getClassMethod([UIFont class], @selector(systemFontOfSize:)); //获取自定义方法地址 Method customMethod = class_getClassMethod([UIFont class], @selector(zs_systemFontOfSize:)); //交换两个方法的实现 method_exchangeImplementations(sytemMethod, customMethod);&#125; 二、实现分类添加新属性我们在开发中常常使用类目Category为一些已有的类扩展功能。虽然继承也能够为已有类增加新的方法，而且相比类目更是具有增加属性的优势，但是继承毕竟是一个重量级的操作，添加不必要的继承关系无疑增加了代码的复杂度。 有时候需要给系统的一些类添加一些属性，也可以用这个实现。 遗憾的是，OC的类目并不支持直接添加属性，如果我们直接在分类的声明中写入Property属性，那么只能为其生成set与get方法声明，却不能生成成员变量，直接调用这些属性还会造成崩溃。所以为了实现给分类添加属性，我们还需借助Runtime的关联对象(Associated Objects)特性，它能够帮助我们在运行阶段将任意的属性关联到一个对象上，下面是相关的三个方法：1234567891011121314151617181920212223242526272829/** 1.给对象设置关联属性 @param object 需要设置关联属性的对象，即给哪个对象关联属性 @param key 关联属性对应的key，可通过key获取这个属性， @param value 给关联属性设置的值 @param policy 关联属性的存储策略(对应Property属性中的assign,copy，retain等) OBJC_ASSOCIATION_ASSIGN @property(assign)。 OBJC_ASSOCIATION_RETAIN_NONATOMIC @property(strong, nonatomic)。 OBJC_ASSOCIATION_COPY_NONATOMIC @property(copy, nonatomic)。 OBJC_ASSOCIATION_RETAIN @property(strong,atomic)。 OBJC_ASSOCIATION_COPY @property(copy, atomic)。 */void objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value, objc_AssociationPolicy policy)/** 2.通过key获取关联的属性 @param object 从哪个对象中获取关联属性 @param key 关联属性对应的key @return 返回关联属性的值 */id _Nullable objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key)/** 3.移除对象所关联的属性 @param object 移除某个对象的所有关联属性 */void objc_removeAssociatedObjects(id _Nonnull object) 注意：key与关联属性一一对应，我们必须确保其全局唯一性，常用我们使用@selector(methodName)作为key。 三、获取类的详细信息 1.获取属性列表1234567unsigned int count;objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);for (unsigned int i = 0; i&lt;count; i++) &#123; const char *propertyName = property_getName(propertyList[i]); NSLog(@&quot;PropertyName(%d): %@&quot;,i,[NSString stringWithUTF8String:propertyName]);&#125;free(propertyList); 2.获取所有成员变量1234567Ivar *ivarList = class_copyIvarList([self class], &amp;count);for (int i= 0; i&lt;count; i++) &#123; Ivar ivar = ivarList[i]; const char *ivarName = ivar_getName(ivar); NSLog(@&quot;Ivar(%d): %@&quot;, i, [NSString stringWithUTF8String:ivarName]);&#125;free(ivarList); 3.获取所有方法1234567Method *methodList = class_copyMethodList([self class], &amp;count);for (unsigned int i = 0; i&lt;count; i++) &#123; Method method = methodList[i]; SEL mthodName = method_getName(method); NSLog(@&quot;MethodName(%d): %@&quot;,i,NSStringFromSelector(mthodName));&#125;free(methodList); 4.获取当前遵循的所有协议1234567__unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);for (int i=0; i&lt;count; i++) &#123; Protocol *protocal = protocolList[i]; const char *protocolName = protocol_getName(protocal); NSLog(@&quot;protocol(%d): %@&quot;,i, [NSString stringWithUTF8String:protocolName]);&#125;free(propertyList); 注意：C语言中使用Copy操作的方法，要注意释放指针，防止内存泄漏 四、解决同一方法高频率调用的效率问题Runtime源码中的IMP作为函数指针，指向方法的实现。通过它，我们可以绕开发送消息的过程来提高函数调用的效率。当我们需要持续大量重复调用某个方法的时候，会十分有用，具体代码示例如下：123456void (*setter)(id, SEL, BOOL);int i;setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];for ( i = 0 ; i &lt; 1000 ; i++ ) setter(targetList[i], @selector(setFilled:), YES); 五、方法动态解析与消息转发1.动态方法解析：动态添加方法Runtime足够强大，能够让我们在运行时动态添加一个未实现的方法，这个功能主要有两个应用场景：场景1：动态添加未实现方法，解决代码中因为方法未找到而报错的问题；场景2：利用懒加载思路，若一个类有很多个方法，同时加载到内存中会耗费资源，可以使用动态解析添加方法。方法动态解析主要用到的方法如下：1234567891011121314151617181920//OC方法：//类方法未找到时调起，可于此添加类方法实现+ (BOOL)resolveClassMethod:(SEL)sel//实例方法未找到时调起，可于此添加实例方法实现+ (BOOL)resolveInstanceMethod:(SEL)sel//Runtime方法：/** 运行时方法：向指定类中添加特定方法实现的操作 @param cls 被添加方法的类 @param name selector方法名 @param imp 指向实现方法的函数指针 @param types imp函数实现的返回值与参数类型 @return 添加方法是否成功 */BOOL class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) 2.解决方法无响应崩溃问题执行OC方法其实就是一个发送消息的过程，若方法未实现，我们可以利用方法动态解析与消息转发来避免程序崩溃，主要使用到的相关方法如下：消息接收者重定向12345//重定向类方法的消息接收者，返回一个类- (id)forwardingTargetForSelector:(SEL)aSelector//重定向实例方法的消息接受者，返回一个实例对象- (id)forwardingTargetForSelector:(SEL)aSelector 消息重定向123- (void)forwardInvocation:(NSInvocation *)anInvocation；- (NSMethodSignature*)methodSignatureForSelector:(SEL)aSelector; 六、动态操作属性1.动态修改属性变量现在假设这样一个情况：我们使用第三方框架里的Person类，在特殊需求下想要更改其私有属性nickName，这样的操作我们就可以使用Runtime可以动态修改对象属性。基本思路：首先使用Runtime获取Peson对象的所有属性，找到nickName，然后使用ivar的方法修改其值。具体的代码示例如下：12345678910111213141516Person *ps = [[Person alloc] init];NSLog(@&quot;ps-nickName: %@&quot;,[ps valueForKey:@&quot;nickName&quot;]); //null//第一步：遍历对象的所有属性unsigned int count;Ivar *ivarList = class_copyIvarList([ps class], &amp;count);for (int i= 0; i&lt;count; i++) &#123; //第二步：获取每个属性名 Ivar ivar = ivarList[i]; const char *ivarName = ivar_getName(ivar); NSString *propertyName = [NSString stringWithUTF8String:ivarName]; if ([propertyName isEqualToString:@&quot;_nickName&quot;]) &#123; //第三步：匹配到对应的属性，然后修改；注意属性带有下划线 object_setIvar(ps, ivar, @&quot;梧雨北辰&quot;); &#125;&#125;NSLog(@&quot;ps-nickName: %@&quot;,[ps valueForKey:@&quot;nickName&quot;]); //梧雨北辰 总结：此过程类似KVC的取值和赋值 2.实现 NSCoding 的自动归档和解档归档是一种常用的轻量型文件存储方式，但是它有个弊端：在归档过程中，若一个Model有多个属性，我们不得不对每个属性进行处理，非常繁琐。归档操作主要涉及两个方法：encodeObject 和 decodeObjectForKey，现在，我们可以利用Runtime来改进它们，关键的代码示例如下：12345678910111213141516171819202122232425262728293031323334//原理：使用Runtime动态获取所有属性//解档操作- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123; self = [super init]; if (self) &#123; unsigned int count = 0; Ivar *ivarList = class_copyIvarList([self class], &amp;count); for (int i = 0; i &lt; count; i++) &#123; Ivar ivar = ivarList[i]; const char *ivarName = ivar_getName(ivar); NSString *key = [NSString stringWithUTF8String:ivarName]; id value = [aDecoder decodeObjectForKey:key]; [self setValue:value forKey:key]; &#125; free(ivarList); //释放指针 &#125; return self;&#125;//归档操作- (void)encodeWithCoder:(NSCoder *)aCoder&#123; unsigned int count = 0; Ivar *ivarList = class_copyIvarList([self class], &amp;count); for (NSInteger i = 0; i &lt; count; i++) &#123; Ivar ivar = ivarList[i]; NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)]; id value = [self valueForKey:key]; [aCoder encodeObject:value forKey:key]; &#125; free(ivarList); //释放指针&#125; 3.实现字典与模型的转换字典数据转模型的操作在项目开发中很常见，通常我们会选择第三方如YYModel；其实我们也可以自己来实现这一功能，主要的思路有两种：KVC、Runtime.总结字典转化模型过程中需要解决的问题如下： 现在，我们使用Runtime来实现字典转模型的操作，大致的思路是这样：借助Runtime可以动态获取成员列表的特性，遍历模型中所有属性，然后以获取到的属性名为key，在JSON字典中寻找对应的值value；再将每一个对应Value赋值给模型，就完成了字典转模型的目的。首先准备下面的JSON数据用于测试：123456789101112131415161718192021&#123; &quot;id&quot;:&quot;2462079046&quot;, &quot;name&quot;: &quot;梧雨北辰&quot;, &quot;age&quot;:&quot;18&quot;, &quot;weight&quot;:140, &quot;address&quot;:&#123; &quot;country&quot;:&quot;中国&quot;, &quot;province&quot;: &quot;河南&quot; &#125;, &quot;courses&quot;:[&#123; &quot;name&quot;:&quot;Chinese&quot;, &quot;desc&quot;:&quot;语文课&quot; &#125;,&#123; &quot;name&quot;:&quot;Math&quot;, &quot;desc&quot;:&quot;数学课&quot; &#125;,&#123; &quot;name&quot;:&quot;English&quot;, &quot;desc&quot;:&quot;英语课&quot; &#125; ]&#125; 具体的代码实现流程如下：步骤1：创建NSObject的类目NSObject+ZSModel，用于实现字典转模型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485@interface NSObject (ZSModel)+ (instancetype)zs_modelWithDictionary:(NSDictionary *)dictionary;@end//ZSModel协议，协议方法可以返回一个字典，表明特殊字段的处理规则@protocol ZSModel&lt;NSObject&gt;@optional+ (nullable NSDictionary&lt;NSString *, id&gt; *)modelContainerPropertyGenericClass;@end;#import &quot;NSObject+ZSModel.h&quot;#import &lt;objc/runtime.h&gt;@implementation NSObject (ZSModel)+ (instancetype)zs_modelWithDictionary:(NSDictionary *)dictionary&#123; //创建当前模型对象 id object = [[self alloc] init]; //1.获取当前对象的成员变量列表 unsigned int count = 0; Ivar *ivarList = class_copyIvarList([self class], &amp;count); //2.遍历ivarList中所有成员变量，以其属性名为key，在字典中查找Value for (int i= 0; i&lt;count; i++) &#123; //2.1获取成员属性 Ivar ivar = ivarList[i]; NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)] ; //2.2截取成员变量名：去掉成员变量前面的&quot;_&quot;号 NSString *propertyName = [ivarName substringFromIndex:1]; //2.3以属性名为key，在字典中查找value id value = dictionary[propertyName]; //3.获取成员变量类型, 因为ivar_getTypeEncoding获取的类型是&quot;@\&quot;NSString\&quot;&quot;的形式 //所以我们要做以下的替换 NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];// 替换: //3.1去除转义字符：@\&quot;name\&quot; -&gt; @&quot;name&quot; ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;\&quot;&quot; withString:@&quot;&quot;]; //3.2去除@符号 ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;@&quot; withString:@&quot;&quot;]; //4.对特殊成员变量进行处理： //判断当前类是否实现了协议方法，获取协议方法中规定的特殊变量的处理方式 NSDictionary *perpertyTypeDic; if([self respondsToSelector:@selector(modelContainerPropertyGenericClass)])&#123; perpertyTypeDic = [self performSelector:@selector(modelContainerPropertyGenericClass) withObject:nil]; &#125; //4.1处理：字典的key与模型属性不匹配的问题，如id-&gt;uid id anotherName = perpertyTypeDic[propertyName]; if(anotherName &amp;&amp; [anotherName isKindOfClass:[NSString class]])&#123; value = dictionary[anotherName]; &#125; //4.2.处理：模型嵌套模型 if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![ivarType hasPrefix:@&quot;NS&quot;]) &#123; Class modelClass = NSClassFromString(ivarType); if (modelClass != nil) &#123; //将被嵌套字典数据也转化成Model value = [modelClass zs_modelWithDictionary:value]; &#125; &#125; //4.3处理：模型嵌套模型数组 //判断当前Vaue是一个数组，而且存在协议方法返回了perpertyTypeDic if ([value isKindOfClass:[NSArray class]] &amp;&amp; perpertyTypeDic) &#123; Class itemModelClass = perpertyTypeDic[propertyName]; //封装数组：将每一个子数据转化为Model NSMutableArray *itemArray = @[].mutableCopy; for (NSDictionary *itemDic in value) &#123; id model = [itemModelClass zs_modelWithDictionary:itemDic]; [itemArray addObject:model]; &#125; value = itemArray; &#125; //5.使用KVC方法将Vlue更新到object中 if (value != nil) &#123; [object setValue:value forKey:propertyName]; &#125; &#125; free(ivarList); //释放C指针 return object;&#125;@end 8、下面的代码输出什么？12345678910@implementation Son : Father- (id)init &#123; self = [super init]; if (self) &#123; NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); &#125; return self;&#125;@end 结果是： 1两个都打印 Son [self class] 打印Son比较好理解为什么 [super class] 也打印Son呢？原因是： [super class] 会被编译成 id objc_msgSendSuper ( struct objc_super *super, SEL op, ... );, objc_super 的结构是： 1234struct objc_super &#123; id receiver; //消息的实际接收者 Class super_class; //指向当前类的父类&#125;; 当我们使用super来接收消息时，编译器会生成一个objc_super结构体。结构体的receiver就是当前类的对象，与self相同；superClass指向当前类的父类。 而 objc_msgSendSuper 函数实际的操作是：从objc_super结构体指向的superClass的方法列表开始查找selector，找到后以objc-&gt;receiver去调用这个selector，最后的操作流程就是如下方式了1objc_msgSend(objc_super-&gt;receiver, @selector(xxx)) 那看起来不就和直接调 objc_msgSend(receiver, @selector(xxx)) 一样了吗？区别是 直接调用是从当前类的方法列表开始查找selector，而objc_msgSendSuper是从父类开始查找 #9、下面代码输出啥？1234BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];BOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]];BOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]]; 第一个是YES ，其他都是NO 12345678910- (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;- (BOOL)isMemberOfClass:(Class)cls &#123; return [self class] == cls;&#125; 12345678910111213+ (Class)class&#123; return self;&#125;- (Class)class&#123; return object_getClass(self);&#125;而 object_getClass() 方法实际上是返回对象的isa 指针所指的对象：Class object_getClass(id obj)&#123; if (obj) return obj-&gt;getIsa(); else return Nil;&#125; 第一个：[NSObject class] 返回的是 NSObject 类对象 （ NSObject Class）123456- (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125; 执行 isKindOfClass 比较的时候，确定两个东西 reciver 和 参数 clsreciver : [NSObject class] NSObject 类对象cls : 也是 [NSObject class] NSObject 类对象 然后开始执行 isKindOfClass 方法进行比较 ：第一次循环：tcls = [self class] ; 因为self 是 NSObject 类对象，所以 [self class] 就是 NSObject类对象的isa指针所指的东西，就是 NSObject 的元类。cls 是 NSObject 的类对象所以不相等 第二次循环：tcls = tcls-&gt;superclass tcls 当前是NSObject的元类， 元类的superclass 是NSObject的类对象cls 是NSObject的类对象所以想等。 第二个：reciver : [NSObject class] NSObject 类对象cls : 也是 [NSObject class] NSObject 类对象然后开始执行 isMemberOfClass 方法进行比较 ：123- (BOOL)isMemberOfClass:(Class)cls &#123; return [self class] == cls;&#125; self 是 NSObject的类对象， [self class] 是NSObject的元类cls 是NSObject的类对象所以不相等 第三个：reciver : [Sark class] Sark 类对象cls : 也是 [Sark class] Sark 类对象 然后开始执行 isKindOfClass 方法进行比较 ：第一次循环：tcls = [self class] ; 因为self 是 Sark 类对象，所以 [self class] 就是 Sark类对象的isa指针所指的东西，就是 Sark 的元类。cls 是 Sark 的类对象所以不相等 第二次循环：tcls = tcls-&gt;superclass tcls 当前是Sark的元类， 元类的 superclass 是NSObject的元类cls 是 Sark 的类对象所以不相等 第三次循环：tcls = tcls-&gt;superclass tcls 当前是NSObject的元类， 元类的superclass 是NSObject 类对象cls 是 Sark 的类对象所以不相等 第四次循环：tcls = tcls-&gt;superclass tcls 当前是 NSObject 类对象， 类对象的superclass 是nilcls 是 Sark 的类对象跳出循环所以不相等 第四个：reciver : [Sark class] Sark 类对象cls : 也是 [Sark class] Sark 类对象然后开始执行 isMemberOfClass 方法进行比较 ：123- (BOOL)isMemberOfClass:(Class)cls &#123; return [self class] == cls;&#125; self 是 Sark的类对象， [self class] 是Sark的元类cls 是Sark的类对象所以不相等 #10、下面的代码会？Compile Error / Runtime Crash / NSLog…? 1234567891011@interface NSObject (Sark)+ (void)foo;@end@implementation NSObject (Sark)- (void)foo &#123; NSLog(@&quot;IMP: -[NSObject (Sark) foo]&quot;);&#125;@end// 测试代码[NSObject foo];[[NSObject new] foo]; 都会正常打印日志[NSObject foo]; 因为类方法是保存在该类的元类中的，所以调用foo类方法，会去 NSObject的元类中区查找，没找到，那去元类的父类中查找，找到了。[[NSObject new] foo]; 调用实例方法，直接查找对象方法，找到了。 #11、其他 对于Model，打印一个对象的时候，通常打印的都是地址，可以重写description方法，自动获取成员来打印。 12、参考资料：1、Runtime-iOS运行时基础篇2、Runtime-iOS运行时应用篇]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RunLoop]]></title>
    <url>%2F2019%2F07%2F13%2Fios-runloop%2F</url>
    <content type="text"><![CDATA[1、什么是RunLoop？一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。 但是手机上需要一直检测接受用户输入，事件驱动，必须一直活着。 如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的： 1234567function loop() &#123; initialize(); do &#123; var message = get_next_message(); process_message(message); &#125; while (message != quit);&#125; 这种模型通常被称作 Event Loop。 RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 其实就是没事就sleep，如果有时间就唤醒，拿到事件，把事件传给处理的handler OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。 CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。 NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 2、RunLoop能干什么？为什么需要RunLoop？手机不同于其他设备，需要一直检测接受用户输入，事件驱动，线程必须一直活着。 通过RunLoop可以让程序保持一直运行，并接收用户输入决定程序该何时去处理哪些事件，调用解耦，用户输入事件放到队列事件处理去队列取，这样会互不影响节省cpu时间，如果没有事件让程序不使用cpu，休眠 事件响应、AutoreleasePool、手势识别、界面绘制、定时器、网络请求等都需要RunLoop支持 3、Runloop是如何创建的？和线程有什么关系？CFRunLoop 是基于 pthread 来管理的。 不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent() 函数内部会根据线程是否有Runloop创建或返回一个RunLoop。 线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。 4、RunLoop相关的类都有哪些？他们有什么关系？主要涉及下面几个类：CFRunLoopRefCFRunLoopModeRefCFRunLoopTimerRefCFRunLoopSourceRefCFRunLoopObverserRef CFRunLoopRef 包含 &lt;Set&gt; CFRunLoopModeRef CFRunLoopModeRef 包含 &lt;Set&gt; CFRunLoopSourceRef、&lt;Array&gt; CFRunLoopSourceRef、&lt;Array&gt; CFRunLoopSourceRef 在RunLoop启动的时候需要传入一个Mode，在exit之前不能切换mode，如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入 CFRunLoopSourceRef 是事件产生的地方。有两个版本：Source0 和 Source1。 Source0 只包含了一个回调（函数指针），它并不能主动触发事件。 需要App自己去触发和管理。 比如：UIEvent，CFSocket source1 由runloop和内核管理，mach port驱动，被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。 CFMachPort CFMessagePort CFRunLoopTimerRef 是基于时间的触发器，当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 CFRunLoopObserverRef 是观察者,每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0),// 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),// 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),// 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),// 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7),// 即将退出Loop kCFRunLoopAllActivities = 0x0FFFFFFFU&#125;; 上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 5、RunLoop里的Mode可以删除吗？只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode 他们的名字也是这两个 6、RunLoop是如何进入休眠状态的？进入休眠状态是否还在消耗CPU资源？XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。 Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。 一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port 为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作 RunLoop 的核心就是一个 mach_msg() ，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。 7、RunLoop和AutoreleasePool有什么关系？AutoreleasePool 是在什么时机释放对象的？App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 8、RunLoop 是如何处理事件响应的，比如触摸、锁屏、摇晃、按键、屏幕旋转等等？苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 9、RunLoop 如何处理手势识别？当_UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 10、RunLoop 如何处理界面绘制？和手势识别类似，当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 11、RunLoop 如何处理定时器？一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 12、RunLoop 如何处理 PerformSelecter？当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 13、RunLoop 如何处理 GCD？当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 14、RunLoop 如何处理网络请求？通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。 当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。 NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。 15、可以停止一个RunLoop吗？如果runloop没有input sources或者附加的timer，runloop就会退出，虽然可以将runloop退出，但是苹果并不建议我们这么做，因为系统内部有可能会在当前线程的runloop中添加一些输入源，所以通过手动移除input source或者timer这种方式，并不能保证runloop一定会退出。 可以通过设置超时时间来让RunLoop退出 强制退出线程 不能让RunLoop退出，回到追内存泄漏 Core Foundation下的CFRunLoopStop函数 可以停止RunLoop 16、滑动时timer停止是怎么回事？一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。平时App处于DefaultMode，当timer是加到kCFRunLoopDefaultMode时，会正常重复回调，当滑动ScrollView的时候会切换到 UITrackingRunLoopMode ，这时timer就不会回调了。 一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中 17、runloop的mode作用是什么？model 主要是用来指定事件在运行循环中的优先级的，分为： NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态UITrackingRunLoopMode：ScrollView滑动时UIInitializationRunLoopMode：启动时NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合苹果公开提供的 Mode 有两个： NSDefaultRunLoopMode（kCFRunLoopDefaultMode）NSRunLoopCommonModes（kCFRunLoopCommonModes） 18、参考资料 深入理解RunLoop CoreFoundation 苹果开源代码 Mac OS X 背后的故事]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVC]]></title>
    <url>%2F2019%2F07%2F13%2Fios-kvc%2F</url>
    <content type="text"><![CDATA[1、什么是KVC？KVC（Key-value coding）键值编码，是指iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值。而不需要调用明确的存取方法。这样就可以在运行时动态地访问和修改对象的属性。而不是在编译时确定，这也是iOS开发中的黑魔法之一。 2、KVC相关的方法？主要的方法： 12345678//直接通过Key来取值- (nullable id)valueForKey:(NSString *)key; //通过Key来设值- (void)setValue:(nullable id)value forKey:(NSString *)key; //通过KeyPath来取值- (nullable id)valueForKeyPath:(NSString *)keyPath;//通过KeyPath来设值 - (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; 其他的方法： 1234567891011121314151617181920//默认返回YES，表示如果没有找到Set&lt;Key&gt;方法的话，会按照_key，_iskey，key，iskey的顺序搜索成员，设置成NO就不这样搜索+ (BOOL)accessInstanceVariablesDirectly;//KVC提供属性值正确性验证的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;//这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回。- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;//如果Key不存在，且没有KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常。- (nullable id)valueForUndefinedKey:(NSString *)key;//和上一个方法一样，但这个方法是设值。- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;//如果你在SetValue方法时面给Value传nil，则会调用这个方法- (void)setNilValueForKey:(NSString *)key;//输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys; 3、实现原理是什么？当调用setValue：属性值 forKey：@”name“的代码时，底层的执行机制如下： 1、程序优先调用set:属性值方法，代码通过setter方法完成设置。注意，这里的是指成员变量名，首字母大小写要符合KVC的命名规则，下同 2、如果没有找到setName：方法，KVC机制会检查+ (BOOL)accessInstanceVariablesDirectly方法有没有返回YES，默认该方法会返回YES，如果你重写了该方法让其返回NO的话，那么在这一步KVC会执行setValue：forUndefinedKey：方法，不过一般开发者不会这么做。所以KVC机制会搜索该类里面有没有名为的成员变量，无论该变量是在类接口处定义，还是在类实现处定义，也无论用了什么样的访问修饰符，只在存在以命名的变量，KVC都可以对该成员变量赋值。 3、如果该类即没有set：方法，也没有_成员变量，KVC机制会搜索_is的成员变量。 4、和上面一样，如果该类即没有set：方法，也没有_和_is成员变量，KVC机制再会继续搜索和is的成员变量。再给它们赋值。 5、如果上面列出的方法或者成员变量都不存在，系统将会执行该对象的setValue：forUndefinedKey：方法，默认是抛出异常。 当调用valueForKey：@”name“的代码时，KVC对key的搜索方式不同于setValue：属性值 forKey：@”name“，其搜索方式如下： 1、首先按get,,is的顺序方法查找getter方法，找到的话会直接调用。如果是BOOL或者Int等值类型， 会将其包装成一个NSNumber对象。 2、如果上面的getter没有找到，KVC则会查找countOf,objectInAtIndex或AtIndexes格式的方法。如果countOf方法和另外两个方法中的一个被找到，那么就会返回一个可以响应NSArray所有方法的代理集合(它是NSKeyValueArray，是NSArray的子类)，调用这个代理集合的方法，或者说给这个代理集合发送属于NSArray的方法，就会以countOf,objectInAtIndex或AtIndexes这几个方法组合的形式调用。还有一个可选的get:range:方法。所以你想重新定义KVC的一些功能，你可以添加这些方法，需要注意的是你的方法名要符合KVC的标准命名方法，包括方法签名。 3、如果上面的方法没有找到，那么会同时查找countOf，enumeratorOf,memberOf格式的方法。如果这三个方法都找到，那么就返回一个可以响应NSSet所的方法的代理集合，和上面一样，给这个代理集合发NSSet的消息，就会以countOf，enumeratorOf,memberOf组合的形式调用。 可能上面的两条查找方案不好理解，简单来说就是如果你在自己的类自定义了KVC的实现，并且实现了上面的方法，那么你可以将返回的对象当数组(NSArray)用 4、如果还没有找到，再检查类方法+ (BOOL)accessInstanceVariablesDirectly,如果返回YES(默认行为)，那么和先前的设值一样，会按_,_is,,is的顺序搜索成员变量名，这里不推荐这么做，因为这样直接访问实例变量破坏了封装性，使代码更脆弱。如果重写了类方法+ (BOOL)accessInstanceVariablesDirectly返回NO的话，那么会直接调用valueForUndefinedKey: 5、还没有找到的话，调用valueForUndefinedKey: 大致实现原理如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182@interface NSObject(MYKVC)-(void)setMyValue:(id)value forKey:(NSString*)key;-(id)myValueforKey:(NSString*)key;@end@implementation NSObject(MYKVC)-(void)setMyValue:(id)value forKey:(NSString *)key&#123; if (key == nil || key.length == 0) &#123; //key名要合法 return; &#125; if ([value isKindOfClass:[NSNull class]]) &#123; [self setNilValueForKey:key]; //如果需要完全自定义，那么这里需要写一个setMyNilValueForKey，但是必要性不是很大，就省略了 return; &#125; if (![value isKindOfClass:[NSObject class]]) &#123; @throw @&quot;must be s NSObject type&quot;; return; &#125; NSString* funcName = [NSString stringWithFormat:@&quot;set%@:&quot;,key.capitalizedString]; if ([self respondsToSelector:NSSelectorFromString(funcName)]) &#123; //默认优先调用set方法 [self performSelector:NSSelectorFromString(funcName) withObject:value]; return; &#125; unsigned int count; BOOL flag = false; Ivar* vars = class_copyIvarList([self class], &amp;count); for (NSInteger i = 0; i&lt;count; i++) &#123; Ivar var = vars[i]; NSString* keyName = [[NSString stringWithCString:ivar_getName(var) encoding:NSUTF8StringEncoding] substringFromIndex:1]; if ([keyName isEqualToString:[NSString stringWithFormat:@&quot;_%@&quot;,key]]) &#123; flag = true; object_setIvar(self, var, value); break; &#125; if ([keyName isEqualToString:key]) &#123; flag = true; object_setIvar(self, var, value); break; &#125; &#125; if (!flag) &#123; [self setValue:value forUndefinedKey:key];//如果需要完全自定义，那么这里需要写一个self setMyValue:value forUndefinedKey:key，但是必要性不是很大，就省略了 &#125;&#125;-(id)myValueforKey:(NSString *)key&#123; if (key == nil || key.length == 0) &#123; return [NSNull new]; //其实不能这么写的 &#125; //这里为了更方便，我就不做相关集合的方法查询了 NSString* funcName = [NSString stringWithFormat:@&quot;gett%@:&quot;,key.capitalizedString]; if ([self respondsToSelector:NSSelectorFromString(funcName)]) &#123; return [self performSelector:NSSelectorFromString(funcName)]; &#125; unsigned int count; BOOL flag = false; Ivar* vars = class_copyIvarList([self class], &amp;count); for (NSInteger i = 0; i&lt;count; i++) &#123; Ivar var = vars[i]; NSString* keyName = [[NSString stringWithCString:ivar_getName(var) encoding:NSUTF8StringEncoding] substringFromIndex:1]; if ([keyName isEqualToString:[NSString stringWithFormat:@&quot;_%@&quot;,key]]) &#123; flag = true; return object_getIvar(self, var); break; &#125; if ([keyName isEqualToString:key]) &#123; flag = true; return object_getIvar(self, var); break; &#125; &#125; if (!flag) &#123; [self valueForUndefinedKey:key];//如果需要完全自定义，那么这里需要写一个self myValueForUndefinedKey，但是必要性不是很大，就省略了 &#125; return [NSNull new]; //其实不能这么写的&#125;@end 4、KVC 如何处理异常?KVC中最常见的异常就是不小心使用了错误的key，或者在设值中不小心传递了nil的值，KVC中有专门的方法来处理这些异常。 通常在用KVC操作Model时，抛出异常的那两个方法是需要重写的。虽然一般很小出现传递了错误的Key值这种情况，但是如果不小心出现了，直接抛出异常让APP崩溃显然是不合理的。一般在这里直接让这个key打印出来即可，或者有些特殊情况需要特殊处理。通常情况下，KVC不允许你要在调用setValue：属性值 forKey：@”name“(或者keyPath)时对非对象传递一个nil的值。很简单，因为值类型是不能为nil的。如果你不小心传了，KVC会调用setNilValueForKey:方法。这个方法默认是抛出异常，所以一般而言最好还是重写这个方法。 123- (nullable id)valueForUndefinedKey:(NSString *)key;- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;- (void)setNilValueForKey:(NSString *)key; 5、KVC如何处理非对象和自定义对象 ?不是每一个方法都返回对象，但是valueForKey：总是返回一个id对象，如果原本的变量类型是值类型或者结构体，返回值会封装成NSNumber或者NSValue对象。这两个类会处理从数字，布尔值到指针和结构体任何类型。然后开发者需要手动转换成原来的类型。尽管valueForKey：会自动将值类型封装成对象，但是setValue：forKey：却不行。你必须手动将值类型转换成NSNumber或者NSValue类型，才能传递过去。 对于自定义对象，KVC也会正确地设值和取值。因为传递进去和取出来的都是id类型，所以需要开发者自己担保类型的正确性，运行时Objective-C在发送消息时会检查类型，如果错误会直接抛出异常。 6、KVC处理容器类?对象的属性可以是一对一的，也可以是一对多的。一对多的属性要么是有序的(数组)，要么是无序的(集合)。 不可变的有序容器属性(NSArray)和无序容器属性(NSSet)一般可以使用valueForKey:来获取。比如有一个叫items的NSArray属性，你可以用valurForKey:@”items”来获取这个属性。前面valueForKey:的key搜索模式中，我们发现其实KVC使用了一种更灵活的方式来管理容器类。苹果的官方文档也推荐我们实现这些这些特殊的访问器。而当对象的属性是可变的容器时，对于有序的容器，可以用下面的方法： (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;```123456789101112131415161718192021222324252627282930313233该方法返回一个可变有序数组，如果调用该方法，KVC的搜索顺序如下：1、搜索insertObject:in&lt;Key&gt;AtIndex: , removeObjectFrom&lt;Key&gt;AtIndex: 或者 insert&lt;Key&gt;AdIndexes , remove&lt;Key&gt;AtIndexes 格式的方法如果至少找到一个insert方法和一个remove方法，那么同样返回一个可以响应NSMutableArray所有方法代理集合(类名是NSKeyValueFastMutableArray2)，那么给这个代理集合发送NSMutableArray的方法，以insertObject:in&lt;Key&gt;AtIndex: , removeObjectFrom&lt;Key&gt;AtIndex: 或者 insert&lt;Key&gt;AdIndexes , remove&lt;Key&gt;AtIndexes组合的形式调用。还有两个可选实现的接口：replaceOnjectAtIndex:withObject:,replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:。2、如果上步的方法没有找到，则搜索set&lt;Key&gt;: 格式的方法，如果找到，那么发送给代理集合的NSMutableArray最终都会调用set&lt;Key&gt;:方法。 也就是说，mutableArrayValueForKey:取出的代理集合修改后，用set&lt;Key&gt;: 重新赋值回去去。这样做效率会低很多。所以推荐实现上面的方法。3、如果上一步的方法还还没有找到，再检查类方法+ (BOOL)accessInstanceVariablesDirectly,如果返回YES(默认行为)，会按_&lt;key&gt;,&lt;key&gt;,的顺序搜索成员变量名，如果找到，那么发送的NSMutableArray消息方法直接交给这个成员变量处理。4、如果还是找不到，则调用valueForUndefinedKey:。而对于无序的容器，可以用下面的方法：- (NSMutableSet *)mutableSetValueForKey:(NSString *)key;该方法返回一个可变的无序数组如果调用该方法，KVC的搜索顺序如下：1、搜索addObject&lt;Key&gt;Object: , remove&lt;Key&gt;Object: 或者 add&lt;Key&gt; , remove&lt;Key&gt; 格式的方法如果至少找到一个insert方法和一个remove方法，那么同样返回一个可以响应NSMutableSet所有方法代理集合(类名是NSKeyValueFastMutableSet2)，那么给这个代理集合发送NSMutableSet的方法，以addObject&lt;Key&gt;Object: , remove&lt;Key&gt;Object: 或者 add&lt;Key&gt; , remove&lt;Key&gt;组合的形式调用。还有两个可选实现的接口：intersect&lt;Key&gt; , set&lt;Key&gt;: 。如果receiver是ManagedObject，那么就不会继续搜索。2、如果上一步的方法没有找到，则搜索set&lt;Key&gt;: 格式的方法，如果找到，那么发送给代理集合的NSMutableSet最终都会调用set&lt;Key&gt;:方法。 也就是说，mutableSetValueForKey取出的代理集合修改后，用set&lt;Key&gt;: 重新赋值回去去。这样做效率会低很多。所以推荐实现上面的方法。3、如果上一步的方法还没有找到，再检查类方法+ (BOOL)accessInstanceVariablesDirectly,如果返回YES(默认行为)，会按_&lt;key&gt;,&lt;key&gt;的顺序搜索成员变量名，如果找到，那么发送的NSMutableSet消息方法直接交给这个成员变量处理。4、如果还是找不到，调用valueForUndefinedKey:可见，除了检查receiver是ManagedObject以外，其搜索顺序和mutableArrayValueForKey基本一致。# 7、KVC 如何处理字典?当对NSDictionary对象使用KVC时，valueForKey:的表现行为和objectForKey:一样。所以使用valueForKeyPath:用来访问多层嵌套的字典是比较方便的。KVC里面还有两个关于NSDictionary的方法 //是指输入一组key，返回这组key对应的属性，再组成一个字典。 (NSDictionary )dictionaryWithValuesForKeys:(NSArray&lt;NSString &gt; *)keys;//是用来修改Model中对应key的属性,字典里传属性名和值 (void)setValuesForKeysWithDictionary:(NSDictionary *)keyedValues; 12345# 8、KVC校验值得正确性？KVC提供了属性值,用来验证key对应的Value是否可用的方法 (BOOL)validateValue:(inout id nullable * nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError; 12这个方法的默认实现是去探索类里面是否有一个这样的方法：`-(BOOL)validate&lt;Key&gt;:error:`如果有这个方法，就调用这个方法来返回，没有的话就直接返回YES @implementation Address-(BOOL)validateCountry:(id )value error:(out NSError _Nullable __autoreleasing )outError{ //在implementation里面加这个方法，它会验证是否设了非法的value NSString country = *value; country = country.capitalizedString; if ([country isEqualToString:@”Japan”]) { return NO; //如果国家是日本，就返回NO，这里省略了错误提示， } return YES;}@end123456789101112131415161718192021222324252627如上面的代码，当开发者需要验证能不能用KVC设定某个值时，可以调用validateValue: forKey:这个方法来验证，如果这个类的开发者实现了-(BOOL)validate&lt;Key&gt;:error:这个方法，那么KVC就会直接调用这个方法来返回，如果没有，就直接返回YES，注意，KVC在设值时不会主动去做验证，需要开发者手动去验证。所以即使你在类里面写了验证方法，但是KVC因为不会去主动验证，所以还是能够设值成功。# 9、具体使用场景有哪些？1、动态地取值和设值利用KVC动态的取值和设值是最基本的用途了2、用KVC来访问和修改私有变量对于类里的私有属性，Objective-C是无法直接访问的，但是KVC是可以的。3、Model和字典转换充分地运用KVC和Objc的runtime组合的技巧，可以实现很多功能，比如给Model实现统一的description用于打印model4、修改一些控件的内部属性很多UI控件都由很多内部UI控件组合而成的，但是Apple度没有提供这访问这些控件的API，这样我们就无法正常地访问和修改这些控件的样式。而KVC在大多数情况可下可以解决这个问题。最常用的就是个性化UITextField中的placeHolderText相关属性，颜色啥的。当日具体属性名称可以通过Runtime相关方法来获取5、更方便的操作集合Apple对KVC的valueForKey:方法作了一些特殊的实现，比如说NSArray和NSSet这样的容器类就实现了这些方法。所以可以用KVC很方便地操作集合比如 求和、首字母变大写等等。。用KVC实现高阶消息传递当对容器类使用KVC时，valueForKey:将会被传递给容器中的每一个对象，而不是容器本身进行操作。结果会被添加进返回的容器中，这样，开发者可以很方便的操作集合来返回另一个集合。 NSArray arrStr = @[@”english”,@”franch”,@”chinese”];NSArray arrCapStr = [arrStr valueForKey:@”capitalizedString”];for (NSString str in arrCapStr) { NSLog(@”%@”,str);}NSArray arrCapStrLength = [arrStr valueForKeyPath:@”capitalizedString.length”];for (NSNumber* length in arrCapStrLength) { NSLog(@”%ld”,(long)length.integerValue);}打印结果2016-04-20 16:29:14.239 KVCDemo[1356:118667] English2016-04-20 16:29:14.240 KVCDemo[1356:118667] Franch2016-04-20 16:29:14.240 KVCDemo[1356:118667] Chinese2016-04-20 16:29:14.240 KVCDemo[1356:118667] 72016-04-20 16:29:14.241 KVCDemo[1356:118667] 62016-04-20 16:29:14.241 KVCDemo[1356:118667] 712345678方法capitalizedString被传递到NSArray中的每一项，这样，NSArray的每一员都会执行capitalizedString并返回一个包含结果的新的NSArray。从打印结果可以看出，所有String都成功以转成了大写。同样如果要执行多个方法也可以用valueForKeyPath:方法。它先会对每一个成员调用 capitalizedString方法，然后再调用length，因为lenth方法返回是一个数字，所以返回结果以NSNumber的形式保存在新数组里用KVC中的函数操作集合KVC同时还提供了很复杂的函数，主要有下面这些①简单集合运算符简单集合运算符共有 `@avg， @count ， @max ， @min ，@sum5` 种，目前还不支持自定义。 @interface Book : NSObject@property (nonatomic,copy) NSString* name;@property (nonatomic,assign) CGFloat price;@end@implementation Book@end Book book1 = [Book new];book1.name = @”The Great Gastby”;book1.price = 22;Book book2 = [Book new];book2.name = @”Time History”;book2.price = 12;Book *book3 = [Book new];book3.name = @”Wrong Hole”;book3.price = 111; Book *book4 = [Book new];book4.name = @”Wrong Hole”;book4.price = 111; NSArray arrBooks = @[book1,book2,book3,book4];NSNumber sum = [arrBooks valueForKeyPath:@”@sum.price”];NSLog(@”sum:%f”,sum.floatValue);NSNumber avg = [arrBooks valueForKeyPath:@”@avg.price”];NSLog(@”avg:%f”,avg.floatValue);NSNumber count = [arrBooks valueForKeyPath:@”@count”];NSLog(@”count:%f”,count.floatValue);NSNumber min = [arrBooks valueForKeyPath:@”@min.price”];NSLog(@”min:%f”,min.floatValue);NSNumber max = [arrBooks valueForKeyPath:@”@max.price”];NSLog(@”max:%f”,max.floatValue); 打印结果2016-04-20 16:45:54.696 KVCDemo[1484:127089] sum:256.0000002016-04-20 16:45:54.697 KVCDemo[1484:127089] avg:64.0000002016-04-20 16:45:54.697 KVCDemo[1484:127089] count:4.0000002016-04-20 16:45:54.697 KVCDemo[1484:127089] min:12.0000002016-04-20 16:45:54.697 KVCDemo[1484:127089] max:111.0000001234567②对象运算符比集合运算符稍微复杂，能以数组的方式返回指定的内容，一共有两种：@distinctUnionOfObjects@unionOfObjects它们的返回值都是NSArray，区别是前者返回的元素都是唯一的，是去重以后的结果；后者返回的元素是全集。用法如下： NSLog(@”distinctUnionOfObjects”);NSArray arrDistinct = [arrBooks valueForKeyPath:@”@distinctUnionOfObjects.price”];for (NSNumber price in arrDistinct) { NSLog(@”%f”,price.floatValue);}NSLog(@”unionOfObjects”);NSArray arrUnion = [arrBooks valueForKeyPath:@”@unionOfObjects.price”];for (NSNumber price in arrUnion) { NSLog(@”%f”,price.floatValue);} 2016-04-20 16:47:34.490 KVCDemo[1522:128840] distinctUnionOfObjects2016-04-20 16:47:34.490 KVCDemo[1522:128840] 111.0000002016-04-20 16:47:34.490 KVCDemo[1522:128840] 12.0000002016-04-20 16:47:34.490 KVCDemo[1522:128840] 22.0000002016-04-20 16:47:34.490 KVCDemo[1522:128840] unionOfObjects2016-04-20 16:47:34.490 KVCDemo[1522:128840] 22.0000002016-04-20 16:47:34.490 KVCDemo[1522:128840] 12.0000002016-04-20 16:47:34.490 KVCDemo[1522:128840] 111.0000002016-04-20 16:47:34.490 KVCDemo[1522:128840] 111.000000` 前者会将重复的价格去除后返回所有价格，后者直接返回所有的图书价格。(因为只返回价格，没有返回图书，感觉用处不大。)③Array和Set操作符这种情况更复杂了，说的是集合中包含集合的情况，我们执行了如下的一段代码：@distinctUnionOfArrays@unionOfArrays@distinctUnionOfSets@distinctUnionOfArrays：该操作会返回一个数组，这个数组包含不同的对象，不同的对象是在从关键路径到操作器右边的被指定的属性里@unionOfArrays 该操作会返回一个数组，这个数组包含的对象是在从关键路径到操作器右边的被指定的属性里和@distinctUnionOfArrays不一样，重复的对象不会被移除@distinctUnionOfSets 和@distinctUnionOfArrays类似。因为Set本身就不支持重复。 10、参考资料1、iOS开发技巧系列—详解KVC]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVO]]></title>
    <url>%2F2019%2F07%2F13%2Fios-kvo%2F</url>
    <content type="text"><![CDATA[1、KVO是什么？KVO(Key Value Observing)，是观察者模式在Foundation中的实现 2、KVO 用法？主要有三个方法：1、注册1234567//keyPath就是要观察的属性值//options给你观察键值变化的选择//context方便传输你需要的数据-(void)addObserver:(NSObject *)anObserver forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context 2、实现监听12345//change里存储了一些变化的数据，比如变化前的数据，变化后的数据；如果注册时context不为空，这里context就能接收到。-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context 3、移除1- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; 3、KVO原理?1、当一个object有观察者时，动态创建这个object的类的子类。一般就是 NSKVONotifying_类名 ，同时会重写这个类的 -class方法，返回之前的类，来隐藏实现细节。通过 object_getClass() 这个方法来调用可以进行验证，因为这个方法是返回isa指针。2、对于每个被观察的property，重写其set方法3、在重写的set方法中调用- willChangeValueForKey:和- didChangeValueForKey:通知观察者4、当一个property没有观察者时，删除重写的方法5、当没有observer观察任何一个property时，删除动态创建的子类 KVO会重写这些方法：1234- setXXX:最主要的重写方法，set值时调用通知函数- class 隐藏自己必备啊，返回原来类的class- dealloc 做清理工作- _isKVOA 这就是内部使用的标示了，判断这个类有没被KVO动态生成子类 4、在什么时机创建的这个子类？1、当类A的对象第一次被观察的时候，系统会在运行期动态创建类A的派生类。我们称为B。2、在派生类B中重写类A的setter方法，B类在被重写的setter方法中实现通知机制。3、类B重写会 class方法，将自己伪装成类A。类B还会重写dealloc方法释放资源。4、系统将所有指向类A对象的isa指针指向类B的对象。 5、一个类里有特别多属性都需要观察怎么办？12//返回影响某个key的所有字段+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key; 6、类里有个 数组 NSArray的属性 可以观察内容变化吗？使用mutableArrayValueForKey: 来修改属性内容。 123456789101112131415161718192021222324252627282930@interface demo : NSObject@property (nonatomic,strong) NSMutableArray* arr;@end@implementation demo-(id)init&#123; if (self == [super init])&#123; _arr = [NSMutableArray new]; [self addObserver:self forKeyPath:@&quot;arr&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil]; &#125; return self;&#125;-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context&#123; NSLog(@&quot;%@&quot;,change);&#125;-(void)dealloc&#123; [self removeObserver:self forKeyPath:@&quot;arr&quot;]; //一定要在dealloc里面移除观察&#125;-(void)addItem&#123; //不会触发KVO [_arr addObject:@&quot;1&quot;];&#125;-(void)addItemObserver&#123; //会触发KVO [[self mutableArrayValueForKey:@&quot;arr&quot;] addObject:@&quot;1&quot;];&#125;-(void)removeItemObserver&#123; //会触发KVO [[self mutableArrayValueForKey:@&quot;arr&quot;] removeLastObject];&#125;@end 6、参考资料objc kvo简单探索深入理解KVO机制]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[block]]></title>
    <url>%2F2019%2F07%2F13%2Fios-block%2F</url>
    <content type="text"><![CDATA[1、 block介绍？block是C语言的扩展 12345//block^ returnType (parameter1, parameter2, parameter3, ...) &#123; //block code&#125; block的标志就是^，所有的block必须以^开头returnType表示返回值类型，如果没有返回值一般使用void表示 12//block变量returnType (^blockName) (parameter1, parameter2, ...); 必须包含blockName并且以^开头，是block的标志参数列表可以和声明函数一样，只写出形参类型不需写出形参名称 比如: 123void (^printBlock)(void) = ^ void(void) &#123; NSLog(@&quot;Hello World&quot;); &#125;; 注意：定义block变量的时候不能省略返回值类型、block名称以及形参列表，如果没有参数则用void占位或者不写，这样就能够定义一个block变量。 定义block的时候如果返回值为void可以省略，如果没有形参可以使用void占位或者整个形参列表都省略不写。 简化后：123void (^printBlock)() = ^&#123; NSLog(@&quot;Hello World&quot;); &#125;; 定义block类型 1typedef returnType (^blockTypeName) (parameter1, parameter2, ...) 2、block有哪几类？NSGlobalBlock如果block不捕获外部变量，那么在ARC环境下就是创建一个全局block。全局block存储在全局内存中，不需要在每次调用的时候都在栈中创建，块所使用的整个内存区在编译期已经确定了，因此这种块是一种单例，不需要多次创建。 NSMallocBlock如果block捕获外部变量，那么在ARC环境下就是创了一个堆区block。代码中最常用的block也就是堆区block，当堆区block的引用计数为0时也会像普通对象一样被销毁，再也不能使用了。 NSStackBlock在MRC环境下，默认创建栈区block，一般使用copy函数拷贝到堆区再使用，否则block可能会被释放，在ARC环境下一般不考虑。 3、block捕获变量是怎么回事？123456789101112NSUInteger age = 22;void (^printBlock)() = ^ &#123; NSLog(@&quot;My Age is %ld&quot;, age); //age = 33; // 这里会报错，因为block内部不允许修改变量的值&#125;;//输出 Age is 22NSLog(@&quot;Age is %ld&quot;, age);age = 100;//输出 Age is 100NSLog(@&quot;Age is %ld&quot;, age);//输出 My Age is 22printBlock(); 在执行block之前修改变量的值，并不影响最终block内部代码，这是由于在定义block块的时候编译器已经在编译期将外部变量值赋给了block内部变量（称为“值捕获”），在这时候进行了一次值拷贝，而不是在运行时赋值，因此外部变量的修改不会影响到内部block的输出。 简单理解的话：就是传递了形参给block 变量类型是不可变对象的时候也是一样的，block里捕获的是age当时的指针，所以变量还是指向@”22”，就像函数传了形参进来一样。123456789101112NSString *age = @&quot;22&quot;;void (^printBlock)() = ^ &#123; NSLog(@&quot;My Age is %@&quot;, age); //age = @&quot;33&quot;; // 这里会报错，因为block内部不允许修改变量的值&#125;;//输出 Age is 22NSLog(@&quot;Age is %@&quot;, age);age = @&quot;100&quot;;//输出 Age is 100NSLog(@&quot;Age is %@&quot;, age);//输出 My Age is 22printBlock(); 但是如果捕获的是一个可变类型，也可以理解为像形参一样传进来，外边修改也会影响到里边 12345678910//定义一个NSMutableString类型的变量 NSMutableString *content = [[NSMutableString alloc] initWithString:@&quot;Jiaming Chen&quot;]; void (^printBlock)() = ^ &#123; NSLog(@&quot;%@&quot;, content); &#125;; //输出 Jiaming Chen NSLog(@&quot;%@&quot;, content); [content appendString:@&quot; is a good guy&quot;]; //输出 Jiaming Chen is a good guy printBlock(); 如果希望block捕获的变量在外部修改后也可以影响block内部，或是想在block内部修改捕获的变量，可以使用__block关键字定义变量。简单理解，可以理解传递了参数的指针进来 123456789101112131415//使用__block关键字定义age__block NSUInteger age = 22;void (^printBlock)() = ^ &#123; NSLog(@&quot;My Age is %ld&quot;, age); age = 200;&#125;;//输出 Age is 22NSLog(@&quot;Age is %ld&quot;, age);age = 100;//输出 Age is 100NSLog(@&quot;Age is %ld&quot;, age);//输出 My Age is 100printBlock();//输出 Age is 200NSLog(@&quot;Age is %ld&quot;, age); 上述代码使用__block定义变量age，这样定义以后编译器会在block定义的时候捕获变量的引用而不是拷贝一个值 4、block 循环引用是怎么回事？如何解决？循环引用可以简单理解为A引用了B，而B又引用了A，双方都同时保持对方的一个引用，导致任何时候引用计数都不为0，始终无法释放。 常见的循环引用场景：1、NSTimerNSTimer 的 target 对传入的参数都是强引用， 如果这时候target再持有了 timer 就会循环引用解决方法： 不要在 target的 dealloc里清理timer，应该单独的清理timer方法，打破引用 可以不要强引用target 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#import &lt;Foundation/Foundation.h&gt;@interface NSTimer (YPQBlocksSupport)+ (NSTimer *)ypq_scheduledTimeWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats;@end#import &quot;NSTimer+YPQBlocksSupport.h&quot;@implementation NSTimer (YPQBlocksSupport)+ (NSTimer *)ypq_scheduledTimeWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats&#123; return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(ypq_blockInvoke:) userInfo:[block copy] repeats:repeats];&#125;- (void)ypq_blockInvoke:(NSTimer *)timer&#123; void (^block)() = timer.userInfo; if(block) &#123; block(); &#125;&#125;@end//调用__weak ViewController * weakSelf = self;[NSTimer ypq_scheduledTimeWithTimeInterval:4.0f block:^&#123; ViewController * strongSelf = weakSelf; [strongSelf afterThreeSecondBeginAction]; &#125; repeats:YES]; 注意 ：千万不要忘记 invalidate 2、delegate 正常声明delegate(nonatomic, weak) id delegate; ```12345如果用 strong ，就可能循环引用A 类有个属性是 delegate B 有个成员 是A的对象， 并且把A的delegate 设置成 B， 这样就会相互依赖，3、block @interface ClassA ()@property (nonatomic, copy) dispatch_block_t block;@property (nonatomic, assign) NSInteger tem;@end@implementation ClassA (void)viewDidLoad { [super viewDidLoad]; self.block = ^{self.tem = 1; };}123self持有block，block里又用到self的时候，就会相互持有，导致循环引用一般编译器会提示警告⚠️一般通过打破循环来解决： @interface ClassA ()@property (nonatomic, copy) dispatch_block_t block;@property (nonatomic, assign) NSInteger tem;@end@implementation ClassA (void)viewDidLoad { [super viewDidLoad]; __weak typeof(self) weakSelf = self self.block = ^{ weakSelf.tem = 1; };} 12但是这种解决方法在个别情况下会有问题： __weak typeof(self) weakSelf = self; self.block = ^{ dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@&quot;%@&quot;, weakSelf.str); }); }; self.block(); 123当10s后执行NSLog的时候weakself内存已经被销毁，所以打印为null更好的解决方法： weak typeof(self) weakSelf = self; self.block = ^{ strong typeof(self) strongSelf = weakSelf; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@”%@”, strongSelf.str); }); }; self.block();12345678外部的weakSelf是为了打破环，从而使得没有循环引用，而内部的strongSelf仅仅是个局部变量,会在block执行结束销毁,不会有循环引用。strongSelf 会使self的引用计数+1，所以self不会被立刻销毁，当block执行完self才会被销毁。这样写很麻烦，当日也可以使用 @weakify和@strongify 来简化4、类与类之间的引用比如： 在使用UITableView 的时候，将 UITableView 给 Cell 使用，cell 中的 strong 引用会造成循环引用。 // controller (UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath )indexPath { TestTableViewCell cell =[tableView dequeueReusableCellWithIdentifier:@”UITableViewCellId” forIndexPath:indexPath]; cell.tableView = tableView; return cell;} // cell@interface TestTableViewCell : UITableViewCell@property (nonatomic, strong) UITableView *tableView; // strong 造成循环引用@end1234567解决方法就是：strong 改为 weak# 5、为什么一些系统提供的block不需要考虑循环引用？比如：```+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0); 因为是类方法 block里虽然可能引用self，但是self 并没有引用对象 6、使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api 需要考虑： 所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block 强引用 self ）没有问题，比如这些：1234567[UIView animateWithDuration:duration animations:^&#123; [self.superview layoutIfNeeded]; &#125;]; [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; self.someProperty = xyz; &#125;]; [[NSNotificationCenter defaultCenter] addObserverForName:@&quot;someNotification&quot; object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * notification) &#123; self.someProperty = xyz; &#125;]; 这些情况不需要考虑“引用循环”。 但如果你使用一些参数中可能含有 ivar 的系统 api ，如 GCD 、NSNotificationCenter就要小心一点：比如GCD 内部如果引用了 self，而且 GCD 的其他参数是 ivar，则要考虑到循环引用：1234567__weak __typeof__(self) weakSelf = self;dispatch_group_async(_operationsGroup, _operationsQueue, ^&#123;__typeof__(self) strongSelf = weakSelf;[strongSelf doSomething];[strongSelf doSomethingElse];&#125; ); 类似的：12345678__weak __typeof__(self) weakSelf = self;_observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&quot;testKey&quot; object:nil queue:nil usingBlock:^(NSNotification *note) &#123; __typeof__(self) strongSelf = weakSelf; [strongSelf dismissModalViewControllerAnimated:YES];&#125;]; self –&gt; _observer –&gt; block –&gt; self 显然这也是一个循环引用。 参考资料iOS block探究(一): 基础详解iOS block探究(二): 深入理解iOS中的循环引用循环引用，看我就对了]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[autorelease]]></title>
    <url>%2F2019%2F07%2F13%2Fios-autorelease%2F</url>
    <content type="text"><![CDATA[1、自动释放池的实现原理是什么？1、App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 2、第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。3、第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 4、在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 核心方法就是 ：1234567void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; 而 AutoreleasePollPage 的定义是这样的： 123456789class AutoreleasePoolPage &#123; magic_t const magic; //用于对当前 AutoreleasePoolPage 完整性的校验 id *next;//下一个为空的内存地址 pthread_t const thread; //保存了当前页所在的线程 AutoreleasePoolPage * const parent; //用来构造双向链表 AutoreleasePoolPage *child;//用来构造双向链表 uint32_t const depth; uint32_t hiwat;&#125;; 每一个自动释放池都是由一系列的 AutoreleasePoolPage 组成的，并且每一个 AutoreleasePoolPage 的大小都是 4096 字节（16 进制 0x1000） 在内存中会以栈的形式，先把成员变量存到栈底，然后剩下的空间用来存储加入到自动释放池中的对象。 begin() 和 end() 方法分别指向可存放 自动释放对象 的边界指针next 指向了下一个为空的内存地址，如果 next 指向的地址加入一个 object，它就会移动到下一个为空的内存地址中。 POOL_SENTINEL（哨兵对象） 等价于nilPOOL_SENTINEL nil ```12345678在每个自动释放池初始化调用 objc_autoreleasePoolPush 的时候，都会把一个 POOL_SENTINEL push 到自动释放池的栈顶，并且返回这个 POOL_SENTINEL 哨兵对象。而当方法 objc_autoreleasePoolPop 调用时，就会向自动释放池中的对象发送 release 消息，直到第一个 POOL_SENTINEL。单个自动释放池的执行过程就是 `objc_autoreleasePoolPush() —&gt; [object autorelease] —&gt; objc_autoreleasePoolPop(void *)。`调用栈： [NSObject autorelease]└── id objc_object::rootAutorelease() └── id objc_object::rootAutorelease2()└── static id AutoreleasePoolPage::autorelease(id obj) └── static id AutoreleasePoolPage::autoreleaseFast(id obj) ├── id *add(id obj) ├── static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) │ ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent) │ └── id *add(id obj) └── static id *autoreleaseNoPage(id obj) ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent) └── id *add(id obj) 1234567向一个对象发送- autorelease消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置# 2、main函数里有个 @autoreleasepool 是怎么回事？ int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); }}12实际上代码是： { AtAutoreleasePool autoreleasepool;}1而__AtAutoreleasePool 是： struct AtAutoreleasePool { AtAutoreleasePool() {atautoreleasepoolobj = objc_autoreleasePoolPush();} ~__AtAutoreleasePool() {objc_autoreleasePoolPop(atautoreleasepoolobj);} void * atautoreleasepoolobj;};12所以本质上main函数可以看成： int main(int argc, const char argv[]) { { void atautoreleasepoolobj = objc_autoreleasePoolPush(); // do whatever you want objc_autoreleasePoolPop(atautoreleasepoolobj); } return 0; }1234567891011121314151617@autoreleasepool 只是帮助我们少写了这两行代码而已，让代码看起来更美观，然后要根据上述两个方法来分析自动释放池的实现。# 3、autoreleasepool 是什么时间释放的？1、在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop在即将进入runloop中的时候，调用 _objc_autoreleasePoolPush() 创建自动释放池，优先级最高，在其他操作之前完成释放池创建BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池，这个优先级最低，等所有操作处理完再释放对象。2、手动添加的自动释放池，会在作用域结束立即释放 (void)viewDidLoad { [super viewDidLoad]; @autoreleasepool {NSString *str = [NSString stringWithFormat:@&quot;xx&quot;]; } NSLog(@”%@”, str); // Console: (null)}12345# 4、常见知识点1\使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool： [array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) { // 这里被一个局部@autoreleasepool包围着}];` 2、for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool咯。 5、参考资料：自动释放池的前世今生 —- 深入解析 autoreleasepoolAutoreleasePool底层实现原理黑幕背后的Autorelease]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debug]]></title>
    <url>%2F2019%2F07%2F13%2Fios-debug%2F</url>
    <content type="text"><![CDATA[1、GDB 和 LLDB 有啥区别？GDB: UNIX及UNIX-like下的调试工具。LLDB:LLDB是个开源的内置于XCode的具有REPL(read-eval-print-loop)特征的Debugger，其可以安装C++或者Python插件。 xcode里有内置的Debugger，老版使用的是GDB，xcode自4.3之后默认使用的就是LLDB了。 命令对比：lldb与gdb命令名的对照表 2、LLDB 怎么用？常用命令有哪些？1、help 命令，查看命令列表和帮助比如： help print 2、print 命令 打印基础类型内容 ，可以简写为 pprint 打印出结果的时候，会给结果指定一个变量名 一般是 $x后面可以继续使用这个变量比如 ： p $0 + 100 3、po 命令 输出的Objective-C对象 ，调试器会输出这个 object 的 description。p打印出来的是指针. 4、expression命令 简写就是e,可以用expression来声明新的变量，也可以改变已有变量的值。我们看到e声明的都是 $ 开头的变量。我们在使用时也需要加上 $符号。比如: e NSArray *$array = @[@&quot;sss&quot;,@&quot;bb&quot;,@&quot;cc&quot;] 5、next 命令 简写 n 下一步6、step 步入 简写 s 进入函数7、finish 步出 跳出函数8、continue 简写 c 继续到下个断点，如果没有就直接执行了9、quit 退出 3、expression表达式1、执行某个表达式。 我们在代码运行过程中，可以通过执行某个表达式来动态改变程序运行的轨迹。 假如我们在运行过程中，突然想把self.view颜色改成红色，看看效果。我们不必写下代码，重新run，只需暂停程序，用expression改变颜色，再刷新一下界面，就能看到效果Objective-C 1234// 改变颜色(lldb) expression -- self.view.backgroundColor = [UIColor redColor]// 刷新界面(lldb) expression -- (void)[CATransaction flush] 2、将返回值输出。 也就是说我们可以通过expression来打印东西。 假如我们想打印self.view：12(lldb) expression -- self.view(UIView *) $1 = 0x00007fe322c18a10 参考资料深入了解GDB和LLDB使用LLDB调试程序熟练使用 LLDB，让你调试事半功倍LLDB的使用iOS开发调试 - LLDB使用概览]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习资料收集]]></title>
    <url>%2F2019%2F02%2F16%2Finterview-collect%2F</url>
    <content type="text"><![CDATA[1、Github上学习资料链接 技术必备基础知识iOS题目剑指Offer算法靠谱的iosiOS思维导图 2、网上搜集的资料汇总 2018 - iOS 面试题汇总一般面试题BAT面试题BAT面试题BAT 经典面试题让BAT的offer不再难拿面试心得与总结—BAT、网易、蘑菇街2018-iOS面试题qi]]></content>
  </entry>
  <entry>
    <title><![CDATA[有关工作的思考]]></title>
    <url>%2F2019%2F02%2F16%2Fwork-think1%2F</url>
    <content type="text"><![CDATA[最近关于工作的一些思考，记录一下： 1、找到正确的事情方向比努力更重要，在公司选择最重要的业务和部门，可以思考自己做的事情产生的结果对公司的影响程度来评估。 2、站在更高层次上看一下这个事情 从自己上级或者领导的角度思考一下这个事情，尽可能全局考虑，慢慢也就能胜任更高职位的工作了 3、抓住事情的核心，最关键的问题，抓大放小从繁杂的事物中找到最重要的，产生最大价值的事情去做，不要在一些不重要的事情上浪费太多时间。这样才能保证把重要的事情做好。 4、把事情转化成一个可以输出的东西在工作中没有苦劳，只有功劳。学会把结果转化成成果【专利、组件库、文章、分享、调研报告、程序demo】，这样才能产生好的KPI，对自己的知识梳理也很重要。 5、把自己做的事情打造成品牌 打造核心能力、建立好的口碑在团队中积极推动事情开展，打造自己的公信力和口碑，并不断去影响周边和行业的人。]]></content>
  </entry>
  <entry>
    <title><![CDATA[自己经常用到的一些代码碎片]]></title>
    <url>%2F2017%2F12%2F20%2Fcode-snip%2F</url>
    <content type="text"><![CDATA[Git：1、修改远程分支地址： 1git remote set-url origin 新地址 2、查看当前分支是基于哪个分支创建的1git reflog --date=local --all | grep 要查询的分支名称 Ubuntu:1、创建新用户sudo adduser username 2、更改home目录权限chmod 700 ubuntu/ 3、给用户增加sudo权限usermod -G 27 userName 4、立刻重启：shutdown -r now Nginx:12345678910查看nginx进程ps -ef | grep nginx杀掉所有Nginx程序sudo pkill -9 nginx使用配置文件启动nginxsudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf重新加载nginxsudo /usr/local/nginx/sbin/nginx -s reload Mysql:12ubuntu安装： yum install mysql-server启动：service mysqld start 1创建用户：CREATE USER &apos;david&apos;@&apos;%&apos; IDENTIFIED BY &apos;setpassword&apos;; 1234//给用户授权mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &apos;deployer&apos;@&apos;%&apos; IDENTIFIED BY &apos;youpassword&apos; WITH GRANT OPTION;操作完后切记执行以下命令刷新权限 FLUSH PRIVILEGES iOS:1、设置 “arc” 或者 “非arc” 标记 12非arc：-fno-objc-arcarc: -fobjc-arc Mac:Shell:1、判断文件或者目录是否存在 123456myPath=&quot;/var/log/httpd/&quot; if [ ! -x &quot;$myPath&quot;]; then mkdir &quot;$myPath&quot; else echo &apos;path exist&apos;fi Vim:Python:其他：1、不输出日志 后台运行nohup sh run.sh &gt;/dev/null 2&gt;&amp;1 &amp;]]></content>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC 下安装oursql 出现-lssl未找到问题解决]]></title>
    <url>%2F2017%2F08%2F08%2Foursql-ssl%2F</url>
    <content type="text"><![CDATA[问题：在MAC下安装oursql模块，一直提示library not found for -lssl 错误信息如下： cc -bundle -undefined dynamic_lookup -arch i386 -arch x86_64 -Wl,-F. build/temp.macosx-10.12-intel-2.7/oursqlx/oursql.o build/temp.macosx-10.12-intel-2.7/oursqlx/compat.o -o build/lib.macosx-10.12-intel-2.7/oursql.so -L/usr/local/Cellar/mysql/5.7.18_1/lib -lmysqlclient -lssl -lcrypto ld: library not found for -lssl clang: error: linker command failed with exit code 1 (use -v to see invocation) error: command &apos;cc&apos; failed with exit status 1 解决：说明去/usr/local/Cellar/mysql/5.7.18_1/lib 该目录寻找openssl库，这个目录下并没有这个库 其实在/usr/local/opt/openssl/lib/下是有openssl库文件的，只需要把这个路径链接上就行了 所以执行下面的命令安装即可： sudo env LDFLAGS=&quot;-I/usr/local/opt/openssl/include -L/usr/local/opt/openssl/lib&quot; pip install oursql]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用命令行安装ipa]]></title>
    <url>%2F2017%2F02%2F22%2Fipa-deploy%2F</url>
    <content type="text"><![CDATA[需要的环境：Mac OS 安装工具： [sudo] npm install -g ipa-deploy 使用： ipa-deploy &lt;path_to_ipa_file&gt; 示例： ipa-deploy myapp.ipa 工作原理： # 将ipa文件解压到临时文件夹tmp mkdir ./tmp cd ./tmp unzip &lt;path_to_ipa_file&gt; # 运行 ios-deploy 安装ipa到设备 ios-deploy -b ./Payload/*.app # 清理tmp文件夹 cd .. rm -r ./tmp 作者：Raymond Xie Github链接：https://github.com/floatinghotpot/ipa-deploy 参考链接：ipa-deploy]]></content>
  </entry>
  <entry>
    <title><![CDATA[Objective-C中NSString转换成BOOL类型]]></title>
    <url>%2F2017%2F02%2F10%2Fnsstring-boolvalue%2F</url>
    <content type="text"><![CDATA[一、问题在开发中经常会遇到将字符串类型转换成BOOL类型的情况 比如：服务器下发“0” 或 “1” ，客户端转换成 NO 或 “YES” 一般我们会直接调用 [NSString boolValue] 方法来得到结果，有时候可能结果不正确 二、方法解析先看下官方文档的描述如下： This property is YES on encountering one of &quot;Y&quot;, &quot;y&quot;, &quot;T&quot;, &quot;t&quot;, or a digit 1-9—the method ignores any trailing characters. This property is NO if the receiver doesn’t begin with a valid decimal text representation of a number. The property assumes a decimal representation and skips whitespace at the beginning of the string. It also skips initial whitespace characters, or optional -/+ sign followed by zeroes. 大致意思就是说： 忽略开头的空字符，以 &quot;Y&quot;, &quot;y&quot;, &quot;T&quot;, “t”,1-9开头的字符串都为真，其他都为假 特殊情况 如果全是数字，只要有一个非0的就是真 下面是我测试的结果： NSArray *tests = @[ @&quot;Y&quot;, //YES @&quot;N&quot;, //NO @&quot;T&quot;, //YES @&quot;F&quot;, //NO @&quot;t&quot;, //YES @&quot;f&quot;, //NO @&quot;1&quot;, //YES @&quot;0&quot;, //NO @&quot;Yes&quot;, //YES @&quot;No&quot;, //NO @&quot;AY&quot;, //NO @&quot;NY&quot;, //NO @&quot;YN&quot;, //YES @&quot;No not YES&quot;, //NO @&quot;true&quot;, //YES @&quot;false&quot;, //NO @&quot;To be or not to be&quot;, //YES @&quot;False&quot;, //NO @&quot;3567&quot;, //YES @&quot;0123456789&quot; //YES @“000&quot;, //NO ]; 三、结论所以，如果下发了错误的数据，一不小心就会出错了，最佳实践就是尽量别用这个方法，Json本身就是支持bool类型的，如果用也只用 “1”，“0”，“true”,”false” 这几个字符串来转换 参考资料： 1、官方文档 2、[NSString boolValue]]]></content>
  </entry>
  <entry>
    <title><![CDATA[字节序-大端与小端]]></title>
    <url>%2F2017%2F01%2F15%2Fbyte-endian%2F</url>
    <content type="text"><![CDATA[字节序总是搞混，这里整理一下： 1、计算机单位：位(bit)：计算机的最小单位，可以表示0 和 1 字节(byte)：8个位组成一组 ，称为字节，每个字节可以表示一个文本字符; 2、什么是字节序：字节序：指多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序。 大端字节序：把值的高字节存到低地址，我们平时书写都用这种字节序。 小端字节序：把值的低字节存到低地址 计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。 人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。 计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节。它只知道按顺序读取字节，先读第一个字节，再读第二个字节。如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。 例如: 16进制数（共占三个字节） 大端字节序存储 小端字节序存储 0x112233 【11是高字节 33是低字节】 11 22 33 33 22 11 3、网络字节序计算机之间通过网络进行通信时 需要保持一致的字节序 RFC规定使用“大端”字节序作为网络字节序，所以在网络传输时，发送时需要先在自己的主机上转换为网络字节序，接受到数据再转化为自己主机的字节序 4、查看自己主机自己序可以用一段代码查看自己主机的字节序 #include &lt;stdio.h&gt; int main () { int number = 1; //0x00000001 if(*(char *)&amp;number == 1){ printf(&quot;Little-endian!\n”); }else{ printf(&quot;Big-endian!\n&quot;); } return 0; } int类型的1，在小端字节序下最低位为1，在大端字节序下，最高位为1。所以可以通过判断最低位是否为0来确定该机器的字节序是什么。 Mac下是小端字节序 5、参考资料：1、理解字节序 2、字节序”是个什么鬼？ 3、字节序(byte order)和位序(bit order) 4、Byte and Bit Order Dissection]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用的Mac软件]]></title>
    <url>%2F2017%2F01%2F08%2Fmy-mac-softs%2F</url>
    <content type="text"><![CDATA[整理下自己Mac上常用的软件： 1、CharlesHttp抓包工具，功能很全，支持https，支持修改返回数据等等下载链接： https://www.charlesproxy.com破解补丁：http://pan.baidu.com/s/1o8Cr9Lw 2、nearLock手机和watch上都有相应的app，当靠近时自动解锁Mac，走开始自动锁定Mac，省了不少输入密码的时间,不足是手机上app不能杀掉，而且偶尔反应不太灵敏下载链接： http://nearlock.me 3、Mou MarkDown编辑器下载地址：http://25.io/mou/ 4、StarUML一款非常好用的UML图工具下载地址：http://staruml.io 5、CleanMyMac3清理Mac垃圾的工具下载地址：http://macpaw.com/cleanmymac 6、Parallels Desktop虚拟机工具，可同时运行Windows系统，强烈推荐，非常好用下载地址：http://www.parallels.com/cn/ 7、SouceTree可视化Git版本管理工具下载地址：https://www.sourcetreeapp.com 8、ReederRSS订阅工具下载地址：http://reederapp.com 9、RevealiOS UI 调试工具下载地址：https://revealapp.com破解版：http://pan.baidu.com/s/1i5x8Dbn 10、cornerstone可视化SVN版本管理工具下载地址：http://www.zennaware.com/cornerstone/store.php 11、evernote笔记工具，支持各种平台，非常实用下载地址：https://www.yinxiang.com 12、MplayerX视频工具下载地址：http://mplayerx.org 13、DashMac上文档查阅工具，可离线查看文档 ，有iOS版本已经开源了下载地址：http://kapeli.com 14、sequel pro数据库查看工具下载地址：http://www.sequelpro.com 15、wireshark最好用的网络包分析工具下载地址：https://www.wireshark.org/download.html 16、handbreak视频格式转换工具下载地址：https://handbrake.fr 17、ImageOptim图片压缩工具下载地址：https://imageoptim.com/mac 18、sublime text基础编辑器下载地址：http://www.sublimetext.com 19、jenkinsci工具,把一些重复的工作做成相关的任务，一键搞定下载地址：https://jenkins.io 20、GoToShell快速在finder中打开命令行下载地址：https://itunes.apple.com/cn/app/go2shell/id445770608?mt=12]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello,2017!]]></title>
    <url>%2F2017%2F01%2F01%2Fhello2017%2F</url>
    <content type="text"><![CDATA[随着年龄的增长感觉时间的脚步越来越快，2016转眼就过去了，回想下上半年过的比较辛苦，脑子很乱，下半年好一些，能静下心来思考，一步一个脚印的工作。在创业公司这几年， 太多精力关注于项目和管理的细节，忽略了不少技术的积累，一直置身于极度繁忙的具体事物中，很少停下脚步认真思考 我在做什么？所做事情的意义是什么？是不是在做正确的事？未来会是什么样？直到不久前我才更加深刻的体会到正确的选择可能比努力本身还要重要，我不能一味的埋头于繁忙的工作，我需要更多的思考。年中的时候离开了跟了几年的老大和一起做游戏的小伙伴，也离开了自己看着一步步做出来的游戏，依稀记得很多个周末和夜晚在想怎么把这个游戏做好，因为工作也错过了很多生活中的精彩，当时真心希望能把这件事情做好，但是发现无论如何努力都无法达到想要的那个结果，甚至根本就看不到希望，我毅然决然的离开，只是为了让自己停下来，认真的想一想。下半年新的工作，多少还是有些乏味，但是也学到了不少东西，不像之前每天都特别着急的去赶任务，能空一些时间思考和学习。 《把时间当作朋友》里把7年当作一生来过，2017年是我新的一生的开始，希望自己2017年不浮躁，不断的学习知识和技能，健身、读书、娱乐，能够充实的度过每一天， 坚持每天睡前都能有一会儿时间去思考总结，不断进行自我完善，也希望能与更多的人沟通与分享。感谢朋友们一路的帮助与鼓励，希望大家新的一年一切顺利！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2016%2F12%2F20%2FhowtouseMarkdown%2F</url>
    <content type="text"><![CDATA[1、标题,注意#与文字之间加一个空格# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 展示效果： #一级标题 二级标题三级标题四级标题五级标题六级标题2、列表###无序列表（用* 或者 -） * 简介 * 第一章 * 结束语 展示效果： 简介 第一章 结束语 ###有序列表（用1. 2. 3.） 1. 第一条 2. 第二条 3. 第三条 展示效果： 第一条 第二条 第三条 3、引用&gt; 这里是引用啊 展示效果： 这里是引用啊 4、图片与链接格式:[描述](链接) 图片在前面加! [Mac上MarkDown工具推荐 ：Mou](http://25.io/mou/) ![M](https://avatars2.githubusercontent.com/u/2938786?v=3&amp;u=bfbfd2920ad7fcf69e16db28c68d58ad84e39cfd&amp;s=140) 展示效果：Mac上MarkDown工具推荐 ：Mou 5、粗体与斜体（*包围是粗体 包围是斜体）**这里是粗体** *这里是斜体* 展示效果： 这里是粗体 这里是斜体 6、代码单行代码使用`包围 `git push origin master` 多行代码可以 在开始处空四个空格即可 展示效果： git push origin master while(true){ print(&quot;MarkDown is cool&quot;) } 7、表格| Column1Name | Column2Name | Column3Name | | --------------- |:---------------:| ---------------:| | leftAlign | centerAlign | rightAlign | | leftAlign | centerAlign | rightAlign | | leftAlign | centerAlign | rightAlign | 展示效果 Column1Name Column2Name Column3Name leftAlign centerAlign rightAlign leftAlign centerAlign rightAlign leftAlign centerAlign rightAlign 8、字体大小颜色&lt;font color=#0099ff size=5 face=&quot;黑体&quot;&gt;color=#0099ff size=5 face=&quot;黑体&quot;&lt;/font&gt; size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。 展示效果： color=#0099ff size=5 face=”黑体” 9、其他单个回车视为空格。 连续回车才能分段。 行尾加两个空格，即可段内换行。 *** 表示分割线 符号要和文字之间加上一个字符的空格]]></content>
  </entry>
</search>
